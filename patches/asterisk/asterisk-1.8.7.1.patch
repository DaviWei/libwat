diff -dur --exclude=configure --new-file asterisk-1.8.7.1/build_tools/menuselect-deps.in asterisk-1.8.7.1.patched/build_tools/menuselect-deps.in
--- asterisk-1.8.7.1/build_tools/menuselect-deps.in	2010-12-17 18:52:04.000000000 -0500
+++ asterisk-1.8.7.1.patched/build_tools/menuselect-deps.in	2011-12-05 17:32:01.000000000 -0500
@@ -43,6 +43,7 @@
 POPT=@PBX_POPT@
 PORTAUDIO=@PBX_PORTAUDIO@
 PRI=@PBX_PRI@
+WAT=@PBX_WAT@
 OPENR2=@PBX_OPENR2@
 RESAMPLE=@PBX_RESAMPLE@
 AIS=@PBX_AIS@
diff -dur --exclude=configure --new-file asterisk-1.8.7.1/channels/chan_dahdi.c asterisk-1.8.7.1.patched/channels/chan_dahdi.c
--- asterisk-1.8.7.1/channels/chan_dahdi.c	2011-09-19 12:57:40.000000000 -0400
+++ asterisk-1.8.7.1.patched/channels/chan_dahdi.c	2011-12-05 17:47:15.000000000 -0500
@@ -44,6 +44,7 @@
 	<use>pri</use>
 	<use>ss7</use>
 	<use>openr2</use>
+	<use>wat</use>
 	<support_level>core</support_level>
  ***/
 
@@ -85,6 +86,10 @@
 #include <openr2.h>
 #endif
 
+#ifdef HAVE_WAT
+#include "sig_wat.h"
+#endif
+
 #include "asterisk/lock.h"
 #include "asterisk/channel.h"
 #include "asterisk/config.h"
@@ -318,7 +323,7 @@
 #define NEED_MFDETECT(p) (((p)->sig == SIG_FEATDMF) || ((p)->sig == SIG_FEATDMF_TA) || ((p)->sig == SIG_E911) || ((p)->sig == SIG_FGC_CAMA) || ((p)->sig == SIG_FGC_CAMAMF) || ((p)->sig == SIG_FEATB))
 
 static const char tdesc[] = "DAHDI Telephony Driver"
-#if defined(HAVE_PRI) || defined(HAVE_SS7) || defined(HAVE_OPENR2)
+#if defined(HAVE_PRI) || defined(HAVE_SS7) || defined(HAVE_OPENR2) || defined(HAVE_WAT)
 	" w/"
 	#if defined(HAVE_PRI)
 		"PRI"
@@ -335,6 +340,13 @@
 		#endif	/* defined(HAVE_PRI) || defined(HAVE_SS7) */
 		"MFC/R2"
 	#endif	/* defined(HAVE_OPENR2) */
+	#ifdef HAVE_WAT
+		#if defined(HAVE_PRI) || defined(HAVE_SS7) || defined (HAVE_WAT)
+		" & "
+		#endif  /* defined(HAVE_PRI) || defined(HAVE_SS7) || defined (HAVE_WAT) */
+		"WAT"
+	#endif /* HAVE_WAT */
+
 #endif	/* defined(HAVE_PRI) || defined(HAVE_SS7) || defined(HAVE_OPENR2) */
 ;
 
@@ -359,6 +371,7 @@
 #define SIG_BRI		(0x2000000 | DAHDI_SIG_CLEAR)
 #define SIG_BRI_PTMP	(0X4000000 | DAHDI_SIG_CLEAR)
 #define SIG_SS7		(0x1000000 | DAHDI_SIG_CLEAR)
+#define SIG_GSM                (0x8000000 | DAHDI_SIG_CLEAR)
 #define SIG_MFCR2 	DAHDI_SIG_CAS
 #define	SIG_SF		DAHDI_SIG_SF
 #define SIG_SFWINK 	(0x0100000 | DAHDI_SIG_SF)
@@ -583,6 +596,16 @@
 
 #endif /* HAVE_OPENR2 */
 
+#ifdef HAVE_WAT
+struct dahdi_wat {
+	int sigchannel; /*!< What channel is the UART channel on */
+	struct sig_wat_span wat;
+};
+
+static struct dahdi_wat wats[NUM_SPANS];
+#endif
+
+
 #ifdef HAVE_PRI
 
 struct dahdi_pri {
@@ -966,6 +989,10 @@
 	 */
 	unsigned int manages_span_alarms:1;
 
+#if defined(HAVE_WAT)
+	struct sig_wat_span *wat;
+#endif
+
 #if defined(HAVE_PRI)
 	struct sig_pri_span *pri;
 	int logicalspan;
@@ -1332,6 +1359,11 @@
 #ifdef HAVE_OPENR2
 	struct dahdi_mfcr2_conf mfcr2;
 #endif
+
+#ifdef HAVE_WAT
+	struct dahdi_wat wat;
+#endif
+
 	struct dahdi_params timing;
 	int is_sig_auto; /*!< Use channel signalling from DAHDI? */
 	/*! Continue configuration even if a channel is not there. */
@@ -1377,6 +1409,19 @@
 			.resetinterval = -1,
 		},
 #endif
+#ifdef HAVE_WAT
+		.wat.wat = {
+			.wat_cfg = {
+				.moduletype = WAT_MODULE_TELIT,
+				.timeout_cid_num = 500,
+				.timeout_command = 20000,
+				.progress_poll_interval = 750,
+				.signal_poll_interval = 60*1000,
+				.codec_mask = WAT_CODEC_ALL
+			},
+		},
+#endif
+
 #if defined(HAVE_SS7)
 		.ss7.ss7 = {
 			.called_nai = SS7_NAI_NATIONAL,
@@ -1546,6 +1591,32 @@
 	return handles;
 }
 
+#ifdef HAVE_WAT
+/*!
+ * \internal
+ * \brief Determine if sig_wat handles the signaling.
+ *
+ * \param signaling Signaling to determine if is for sig_wat.
+ *
+ * \return TRUE if the signaling is for sig_wat.
+ */
+static inline int dahdi_sig_wat_lib_handles(int signaling)
+{
+	int handles;
+
+	switch (signaling) {
+		case SIG_GSM:
+			handles = 1;
+			break;
+		default:
+			handles = 0;
+			break;
+	}
+
+	return handles;
+}
+#endif
+
 static enum analog_sigtype dahdisig_to_analogsig(int sig)
 {
 	switch (sig) {
@@ -2546,6 +2617,37 @@
 }
 #endif	/* defined(HAVE_PRI) || defined(HAVE_SS7) */
 
+#ifdef HAVE_WAT
+static struct ast_channel *my_new_wat_ast_channel(void *pvt, int state, int startpbx, int sub, const struct ast_channel *requestor)
+{
+	int dahdi_sub;
+	int audio = 1;
+	struct dahdi_pvt *p = pvt;
+
+	switch (sub) {
+		case WAT_CALL_SUB_REAL:
+			dahdi_sub = SUB_REAL;
+			break;
+		case WAT_CALL_SUB_CALLWAIT:
+			dahdi_sub = SUB_CALLWAIT;
+			break;
+		case WAT_CALL_SUB_THREEWAY:
+			dahdi_sub = SUB_THREEWAY;
+			break;
+		default:
+			ast_log(LOG_ERROR, "Invalid sub!\n");
+			dahdi_sub = SUB_REAL;
+	}
+
+	if (ioctl(p->subs[SUB_REAL].dfd, DAHDI_AUDIOMODE, &audio) == -1) {
+		ast_log(LOG_WARNING, "Unable to set audio mode on channel %d to %d: %s\n",
+							p->channel, audio, strerror(errno));
+	}
+	dahdi_setlaw(p->subs[SUB_REAL].dfd, p->law_default);
+	return dahdi_new(p, state, startpbx, dahdi_sub, DAHDI_LAW_ALAW, requestor ? requestor->linkedid : "");
+}
+#endif /* defined (HAVE_WAT) */
+
 #if defined(HAVE_PRI)
 static struct ast_channel *my_new_pri_ast_channel(void *pvt, int state, enum sig_pri_law law, char *exten, const struct ast_channel *requestor)
 {
@@ -2991,6 +3093,7 @@
 	return dahdi_set_hook(p->subs[ANALOG_SUB_REAL].dfd, DAHDI_ONHOOK);
 }
 
+
 #if defined(HAVE_PRI)
 static void my_pri_fixup_chans(void *chan_old, void *chan_new)
 {
@@ -3347,6 +3450,102 @@
 };
 #endif	/* defined(HAVE_PRI) */
 
+#ifdef HAVE_WAT
+static void wat_handle_sig_exception(struct sig_wat_span *wat)
+{
+	int x;
+	ioctl(wat->fd, DAHDI_GETEVENT, &x);
+	if (x) {
+		ast_log(LOG_NOTICE, "WAT got event: %s (%d) on signalling channel of span %d\n", event2str(x), x, wat->span);
+	}
+	/* Keep track of alarm state */
+	switch (x) {
+		case DAHDI_EVENT_ALARM:
+			wat_event_alarm(wat);
+			break;
+		case DAHDI_EVENT_NOALARM:
+			wat_event_noalarm(wat);
+			break;
+		default:
+			break;
+	}
+}
+
+/*!
+ * \internal
+ * \brief Open the WAT channel media path.
+ * \since 1.8
+ *
+ * \param p Channel private control structure.
+ *
+ * \return Nothing
+ */
+static void my_wat_open_media(void *p)
+{
+	struct dahdi_pvt *pvt = p;
+	int res;
+	int dfd;
+	int set_val;
+
+	dfd = pvt->subs[SUB_REAL].dfd;
+
+	/* Open the media path. */
+	set_val = 1;
+	res = ioctl(dfd, DAHDI_AUDIOMODE, &set_val);
+	if (res < 0) {
+		ast_log(LOG_WARNING, "Unable to enable audio mode on channel %d (%s)\n",
+				pvt->channel, strerror(errno));
+	}
+
+#if 0 /* TODO: find equivalent */
+	/* Set correct companding law for this call. */
+	res = dahdi_setlaw(dfd, pvt->law);
+	if (res < 0) {
+		ast_log(LOG_WARNING, "Unable to set law on channel %d\n", pvt->channel);
+	}
+
+	/* Set correct gain for this call. */
+	if (pvt->digital) {
+		res = set_actual_gain(dfd, 0, 0, pvt->rxdrc, pvt->txdrc, pvt->law);
+	} else {
+		res = set_actual_gain(dfd, pvt->rxgain, pvt->txgain, pvt->rxdrc, pvt->txdrc, pvt->law);
+	}
+	if (res < 0) {
+		ast_log(LOG_WARNING, "Unable to set gains on channel %d\n", pvt->channel);
+	}
+	
+	if (pvt->dsp_features && pvt->dsp) {
+		ast_dsp_set_features(pvt->dsp, pvt->dsp_features);
+		pvt->dsp_features = 0;
+	}
+#endif
+}
+
+static struct sig_wat_callback dahdi_wat_callbacks =
+{
+	.lock_private = my_lock_private,
+	.unlock_private = my_unlock_private,
+	.deadlock_avoidance_private = my_deadlock_avoidance_private,
+
+	.set_echocanceller = my_set_echocanceller,
+	.deadlock_avoidance_private = my_deadlock_avoidance_private,
+	.new_ast_channel = my_new_wat_ast_channel,
+	//.play_tone = my_wat_play_tone,
+
+	.handle_sig_exception = wat_handle_sig_exception,
+	.set_alarm = my_set_alarm,
+	.set_dialing = my_set_dialing,
+	//.set_digital = my_set_digital,
+	//.set_inservice = my_set_inservice,
+	.set_callerid = my_set_callerid,
+	.set_dnid = my_set_dnid,
+	.module_ref = my_module_ref,
+	.module_unref = my_module_unref,
+	.open_media = my_wat_open_media,
+	.set_new_owner = my_set_new_owner,
+};
+#endif /* defined (HAVE_WAT) */
+
 #if defined(HAVE_SS7)
 /*!
  * \internal
@@ -4282,6 +4481,14 @@
 }
 #endif	/* defined(HAVE_PRI) */
 
+#ifdef HAVE_WAT
+static void dahdi_close_wat_fd(struct dahdi_wat *wat)
+{
+	dahdi_close(wat->wat.fd);
+	wat->wat.fd = -1;
+}
+#endif
+
 #if defined(HAVE_SS7)
 static void dahdi_close_ss7_fd(struct dahdi_ss7 *ss7, int fd_num)
 {
@@ -4389,6 +4596,13 @@
 		if (!res)
 			goto out;
 		break;
+#ifdef HAVE_WAT
+	case SIG_GSM:
+		res = sig_wat_digit_begin(pvt->sig_pvt, chan, digit);
+		if (!res)
+			goto out;
+		break;
+#endif
 	default:
 		break;
 	}
@@ -4442,6 +4656,13 @@
 		goto out;
 	}
 #endif
+#ifdef HAVE_WAT
+	/* This means that the digit was already sent via GSM signalling */
+	if (dahdi_sig_wat_lib_handles(pvt->sig) && !pvt->begindigit) {
+		goto out;
+	}
+#endif
+
 
 	if (pvt->begindigit) {
 		x = -1;
@@ -4567,6 +4788,8 @@
 		return "SF (Tone) with Feature Group D (MF)";
 	case SIG_SF_FEATB:
 		return "SF (Tone) with Feature Group B (MF)";
+	case SIG_GSM:
+		return "GSM";
 	case 0:
 		return "Pseudo";
 	default:
@@ -5317,6 +5540,14 @@
 	}
 #endif
 
+#ifdef HAVE_WAT
+	if (dahdi_sig_wat_lib_handles(p->sig)) {
+		res = sig_wat_call(p->sig_pvt, ast, rdest);
+		ast_mutex_unlock(&p->lock);
+		return res;
+	}
+#endif
+
 #if defined(HAVE_SS7)
 	if (p->sig == SIG_SS7) {
 		res = sig_ss7_call(p->sig_pvt, ast, rdest);
@@ -6149,6 +6380,43 @@
 	}
 #endif	/* defined(HAVE_PRI) */
 
+#ifdef HAVE_WAT
+	if (dahdi_sig_wat_lib_handles(p->sig)) {
+		x = 1;
+		ast_channel_setoption(ast, AST_OPTION_AUDIO_MODE, &x, sizeof(char), 0);
+
+		dahdi_confmute(p, 0);
+		p->muting = 0;
+		restore_gains(p);
+		if (p->dsp) {
+				ast_dsp_free(p->dsp);
+				p->dsp = NULL;
+		}
+		p->ignoredtmf = 0;
+
+		/* Real channel, do some fixup */
+		p->subs[SUB_REAL].owner = NULL;
+		p->subs[SUB_REAL].needbusy = 0;
+		dahdi_setlinear(p->subs[SUB_REAL].dfd, 0);
+
+		p->owner = NULL;
+		p->cid_tag[0] = '\0';
+
+		p->outgoing = 0;
+
+		revert_fax_buffers(p, ast);
+
+		sig_wat_hangup(p->sig_pvt, ast);
+
+		dahdi_disable_ec(p);
+
+		update_conf(p);
+		reset_conf(p);
+
+		goto hangup_out;
+	}
+#endif /* HAVE_WAT */
+
 #if defined(HAVE_SS7)
 	if (p->sig == SIG_SS7) {
 		x = 1;
@@ -6378,6 +6646,7 @@
 		switch (p->sig) {
 		case SIG_SS7:
 		case SIG_MFCR2:
+		case SIG_GSM:
 		case SIG_PRI_LIB_HANDLE_CASES:
 		case 0:
 			break;
@@ -6503,6 +6772,11 @@
 		res = sig_pri_answer(p->sig_pvt, ast);
 		break;
 #endif	/* defined(HAVE_PRI) */
+#if defined(HAVE_WAT)
+	case SIG_GSM:
+		res = sig_wat_answer(p->sig_pvt, ast);
+		break;
+#endif
 #if defined(HAVE_SS7)
 	case SIG_SS7:
 		res = sig_ss7_answer(p->sig_pvt, ast);
@@ -12124,6 +12398,9 @@
 #if defined(HAVE_SS7)
 	struct sig_ss7_chan *ss7_chan = NULL;
 #endif	/* defined(HAVE_SS7) */
+#ifdef HAVE_WAT
+	struct sig_wat_chan *wat_chan = NULL;
+#endif
 
 	/* Search channel interface list to see if it already exists. */
 	for (tmp = iflist; tmp; tmp = tmp->next) {
@@ -12220,6 +12497,63 @@
 				}
 				tmp->sig_pvt = analog_p;
 			}
+
+#ifdef HAVE_WAT
+			if (chan_sig == SIG_GSM) {
+				int offset;
+				int matchessigchan;
+				int x;
+
+				offset = (channel - p.chanpos) + 2;
+
+				if (ioctl(tmp->subs[SUB_REAL].dfd, DAHDI_AUDIOMODE, &offset)) {
+					ast_log(LOG_ERROR, "Unable to set clear mode on clear channel %d of span %d: %s\n", channel, p.spanno, strerror(errno));
+					destroy_dahdi_pvt(tmp);
+					return NULL;
+				}
+				if (span >= NUM_SPANS) {
+					ast_log(LOG_ERROR, "Channel %d does not lie on a span I know of (%d)\n", channel, span);
+					destroy_dahdi_pvt(tmp);
+					return NULL;
+				} else {
+					si.spanno = 0;
+					if (ioctl(tmp->subs[SUB_REAL].dfd,DAHDI_SPANSTAT,&si) == -1) {
+						ast_log(LOG_ERROR, "Unable to get span status: %s\n", strerror(errno));
+						destroy_dahdi_pvt(tmp);
+						return NULL;
+					}
+
+					wats[span].sigchannel = offset;
+					wats[span].wat.span = span;
+					wats[span].wat.wat_span_id = span + 1;
+
+					/* Make sure this isn't a sig-channel */
+					matchessigchan=0;
+					for (x = 0; x < NUM_SPANS; x++) {
+						if (wats[x].sigchannel == tmp->channel) {
+							matchessigchan = 1;
+							break;
+						}
+					}
+
+					if (!matchessigchan) {
+						ast_debug(4, "Adding callbacks %p to chan %d\n", &dahdi_wat_callbacks, tmp->channel);
+						wat_chan = sig_wat_chan_new(tmp, &dahdi_wat_callbacks, &wats[span].wat, p.chanpos);
+
+						tmp->sig_pvt = wat_chan;
+						tmp->wat = &wats[span].wat;
+
+						memcpy(&wats[span].wat.wat_cfg, &conf->wat.wat.wat_cfg, sizeof(wats[span].wat.wat_cfg));
+
+						wats[span].wat.pvt = tmp->sig_pvt;
+					} else {
+						destroy_dahdi_pvt(tmp);
+						return NULL;
+					}
+				}
+			}
+#endif
+
 #if defined(HAVE_SS7)
 			if (chan_sig == SIG_SS7) {
 				struct dahdi_ss7 *ss7;
@@ -12767,6 +13101,7 @@
 				case SIG_PRI_LIB_HANDLE_CASES:
 				case SIG_SS7:
 				case SIG_MFCR2:
+				case SIG_GSM:
 					break;
 				default:
 					/* Hang it up to be sure it's good */
@@ -12786,6 +13121,18 @@
 			if ((res = get_alarms(tmp)) != DAHDI_ALARM_NONE) {
 				/* the dchannel is down so put the channel in alarm */
 				switch (tmp->sig) {
+#ifdef HAVE_WAT
+				case SIG_GSM:
+					if (wat_chan) {
+						wat_chan->channel = tmp->channel;
+						ast_copy_string(wat_chan->context, tmp->context,
+														sizeof(wat_chan->context));
+						ast_copy_string(wat_chan->mohinterpret, tmp->mohinterpret,
+														sizeof(wat_chan->mohinterpret));
+					}
+					break;
+#endif /* defined (HAVE_WAT) */
+
 #ifdef HAVE_PRI
 				case SIG_PRI_LIB_HANDLE_CASES:
 					sig_pri_set_alarm(tmp->sig_pvt, !si.alarms);
@@ -13886,6 +14233,60 @@
 }
 #endif /* HAVE_OPENR2 */
 
+#ifdef HAVE_WAT
+static int prepare_wat(struct dahdi_wat *wat)
+{
+	int res, x;
+	struct dahdi_params p;
+	struct dahdi_bufferinfo bi;
+	struct dahdi_spaninfo si;
+
+	wat->wat.calls = &dahdi_wat_callbacks;
+
+	wat->wat.fd = open("/dev/dahdi/channel", O_RDWR);
+	x = wat->sigchannel;
+	if ((wat->wat.fd < 0) || (ioctl(wat->wat.fd,DAHDI_SPECIFY,&x) == -1)) {
+		ast_log(LOG_ERROR, "Unable to open D-channel %d (%s)\n", x, strerror(errno));
+		return -1;
+	}
+	memset(&p, 0, sizeof(p));
+	res = ioctl(wat->wat.fd, DAHDI_GET_PARAMS, &p);
+	if (res) {
+		dahdi_close_wat_fd(wat);
+		ast_log(LOG_ERROR, "Unable to get parameters for Sig-channel %d (%s)\n", x, strerror(errno));
+		return -1;
+	}
+	if ((p.sigtype != DAHDI_SIG_HDLCFCS) && (p.sigtype != DAHDI_SIG_HARDHDLC)) {
+		dahdi_close_wat_fd(wat);
+		ast_log(LOG_ERROR, "Sig-channel %d is not in HDLC/FCS mode.\n", x);
+		return -1;
+	}
+	memset(&si, 0, sizeof(si));
+	res = ioctl(wat->wat.fd, DAHDI_SPANSTAT, &si);
+	if (res) {
+		dahdi_close_wat_fd(wat);
+		ast_log(LOG_ERROR, "Unable to get span state for Sig-channel %d (%s)\n", x, strerror(errno));
+	}
+	if (!si.alarms) {
+		wat_event_noalarm(&wat->wat);
+	} else {
+		wat_event_alarm(&wat->wat);
+	}
+	memset(&bi, 0, sizeof(bi));
+	bi.txbufpolicy = DAHDI_POLICY_IMMEDIATE;
+	bi.rxbufpolicy = DAHDI_POLICY_IMMEDIATE;
+	bi.numbufs = 32;
+	bi.bufsize = 1024;
+	if (ioctl(wat->wat.fd, DAHDI_SET_BUFINFO, &bi)) {
+		ast_log(LOG_ERROR, "Unable to set appropriate buffering on channel %d: %s\n", x, strerror(errno));
+		dahdi_close_wat_fd(wat);
+		return -1;
+	}
+	return 0;
+}
+#endif /* HAVE_WAT */
+
+
 #if defined(HAVE_PRI)
 #ifndef PRI_RESTART
 #error "Upgrade your libpri"
@@ -14915,6 +15316,19 @@
 	}
 #endif
 
+#if defined(HAVE_WAT)
+	for (i = 0; i < NUM_SPANS; i++) {
+		if (wats[i].wat.master && (wats[i].wat.master != AST_PTHREADT_NULL)) {
+			cancel_code = pthread_cancel(wats[i].wat.master);
+			pthread_kill(wats[i].wat.master, SIGURG);
+			ast_debug(4, "Waiting to join thread of span %d with pid=%p, cancel_code=%d\n", i, (void *) wats[i].wat.master, cancel_code);
+			pthread_join(wats[i].wat.master, NULL);
+			ast_debug(4, "Joined thread of span %d\n", i);
+		}
+	}
+#endif
+
+
 #if defined(HAVE_SS7)
 	for (i = 0; i < NUM_SPANS; i++) {
 		if (linksets[i].ss7.master && (linksets[i].ss7.master != AST_PTHREADT_NULL)) {
@@ -16351,6 +16765,161 @@
 };
 #endif	/* defined(HAVE_SS7) */
 
+static char *handle_wat_send_sms(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)
+{
+	int span;
+
+	switch (cmd) {
+		case CLI_INIT:
+			e->command = "wat send sms";
+			e->usage = "Usage: wat send sms <span> <number> <sms>\n"
+					   "       Send a sms on <span> <number> <sms>\n";
+		return NULL;
+		case CLI_GENERATE:
+			return NULL;
+	}
+
+	if (a->argc < 6)
+		return CLI_SHOWUSAGE;
+
+	span = atoi(a->argv[3]);
+	if ((span < 1) || (span > NUM_SPANS)) {
+		ast_cli(a->fd, "Invalid span '%s'.  Should be a number from %d to %d\n", a->argv[3], 1, NUM_SPANS);
+		return CLI_SUCCESS;
+	}
+
+	if (!wats[span-1].wat.wat_span_id) {
+		ast_cli(a->fd, "No WAT running on span %d\n", span);
+		return CLI_SUCCESS;
+	}
+
+	sig_wat_cli_send_sms(a->fd, &wats[span-1].wat, a->argv[4], a->argv[5]);
+	return CLI_SUCCESS;
+}
+
+static char *handle_wat_show_spans(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)
+{
+	int span;
+
+	switch (cmd) {
+		case CLI_INIT:
+			e->command = "wat show spans";
+			e->usage = "Usage: wat show spans\n"
+						"       Displays WAT span information\n";
+			return NULL;
+		case CLI_GENERATE:
+			return NULL;
+	}
+
+	if (a->argc != 3)
+		return CLI_SHOWUSAGE;
+
+	for (span = 0; span < NUM_SPANS; span++) {
+		if (wats[span].wat.wat_span_id) {
+			sig_wat_cli_show_spans(a->fd, span + 1, &wats[span].wat);
+		}
+	}
+	return CLI_SUCCESS;
+}
+
+static char *handle_wat_show_span(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)
+{
+	int span;
+
+	switch (cmd) {
+		case CLI_INIT:
+			e->command = "wat show span";
+			e->usage = "Usage: wat show span <span>\n"
+						"       Displays GSM Information on a given WAT span\n";
+			return NULL;
+		case CLI_GENERATE:
+			return complete_span_4(a->line, a->word, a->pos, a->n);
+	}
+
+	if (a->argc < 4)
+		return CLI_SHOWUSAGE;
+
+	span = atoi(a->argv[3]);
+	if ((span < 1) || (span > NUM_SPANS)) {
+		ast_cli(a->fd, "Invalid span '%s'.  Should be a number from %d to %d\n", a->argv[3], 1, NUM_SPANS);
+		return CLI_SUCCESS;
+	}
+
+	if (!wats[span-1].wat.wat_span_id) {
+		ast_cli(a->fd, "No WAT running on span %d\n", span);
+		return CLI_SUCCESS;
+	}
+
+	sig_wat_cli_show_span(a->fd, &wats[span-1].wat);
+
+	return CLI_SUCCESS;
+}
+
+static char *handle_wat_version(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)
+{
+	unsigned char current = 0;
+	unsigned char revision = 0;
+	unsigned char age = 0;
+
+	switch (cmd) {
+		case CLI_INIT:
+			e->command = "wat show version";
+			e->usage = "Usage: wat show version\n"
+						"       Show the libwat version\n";
+			return NULL;
+		case CLI_GENERATE:
+			return NULL;
+	}
+
+	wat_version(&current, &revision, &age);
+	ast_cli(a->fd, "libwat version: %d.%d.%d\n", current, revision, age);
+
+	return CLI_SUCCESS;
+}
+
+static char *handle_wat_exec_at(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)
+{
+	int span = 0;
+
+	switch (cmd) {
+		case CLI_INIT:
+			e->command = "wat exec";
+			e->usage = "Usage: wat exec <span> <AT command>\n"
+						"       Executes an arbitrary AT command in the given WAT span\n";
+			return NULL;
+		case CLI_GENERATE:
+			return complete_span_4(a->line, a->word, a->pos, a->n);
+	}
+
+	if (a->argc < 4)
+		return CLI_SHOWUSAGE;
+
+	span = atoi(a->argv[2]);
+	if ((span < 1) || (span > NUM_SPANS)) {
+		ast_cli(a->fd, "Invalid span '%s'.  Should be a number from %d to %d\n", a->argv[2], 1, NUM_SPANS);
+		return CLI_SUCCESS;
+	}
+
+	if (!wats[span-1].wat.wat_span_id) {
+		ast_cli(a->fd, "No WAT running on span %d\n", span);
+		return CLI_SUCCESS;
+	}
+
+	sig_wat_cli_exec_at(a->fd, &wats[span-1].wat, a->argv[3]);
+
+	return CLI_SUCCESS;
+}
+
+#if defined(HAVE_WAT)
+static struct ast_cli_entry dahdi_wat_cli[] = {
+	AST_CLI_DEFINE(handle_wat_send_sms, "Sends a SMS"),
+	AST_CLI_DEFINE(handle_wat_show_spans, "Displays WAT span information"),
+	AST_CLI_DEFINE(handle_wat_show_span, "Displays WAT span information"),
+	AST_CLI_DEFINE(handle_wat_exec_at, "Executes an arbitrary AT command"),
+	AST_CLI_DEFINE(handle_wat_version, "Displays libwat version"),
+};
+#endif /* defined(HAVE_WAT) */
+
 #if defined(HAVE_PRI)
 #if defined(HAVE_PRI_CCSS)
 /*!
@@ -16473,6 +17042,14 @@
 	ast_unregister_application(dahdi_send_callrerouting_facility_app);
 #endif
 #endif
+#ifdef HAVE_WAT
+	for (i = 0; i < NUM_SPANS; i++) {
+		if (wats[i].wat.master != AST_PTHREADT_NULL)
+		pthread_cancel(wats[i].wat.master);
+	}
+	ast_cli_unregister_multiple(dahdi_wat_cli, ARRAY_LEN(dahdi_wat_cli));
+#endif
+
 #if defined(HAVE_SS7)
 	for (i = 0; i < NUM_SPANS; i++) {
 		if (linksets[i].ss7.master != AST_PTHREADT_NULL)
@@ -16532,6 +17109,18 @@
 	sig_pri_unload();
 #endif
 
+#ifdef HAVE_WAT
+	for (i = 0; i < NUM_SPANS; i++) {
+		if (wats[i].wat.master && (wats[i].wat.master != AST_PTHREADT_NULL)) {
+			pthread_join(wats[i].wat.master, NULL);
+			dahdi_close_wat_fd(&wats[i]);
+		}
+		if (wats[i].wat.wat_span_id) {
+			sig_wat_stop_wat(&wats[i].wat);
+		}
+	}
+#endif
+
 #if defined(HAVE_SS7)
 	for (i = 0; i < NUM_SPANS; i++) {
 		if (linksets[i].ss7.master && (linksets[i].ss7.master != AST_PTHREADT_NULL))
@@ -17151,6 +17740,10 @@
 				} else if (!strcasecmp(v->value, "mfcr2")) {
 					confp->chan.sig = SIG_MFCR2;
 #endif
+#ifdef HAVE_WAT
+				} else if (!strcasecmp(v->value, "gsm")) {
+					confp->chan.sig = SIG_GSM;
+#endif
 				} else if (!strcasecmp(v->value, "auto")) {
 					confp->is_sig_auto = 1;
 				} else {
@@ -17159,6 +17752,28 @@
 					confp->is_sig_auto = orig_auto;
 					ast_log(LOG_ERROR, "Unknown signalling method '%s' at line %d.\n", v->value, v->lineno);
 				}
+#ifdef HAVE_WAT
+				} else if (!strcasecmp(v->name, "wat_moduletype")) {
+					if (!strcasecmp(v->value, "telit")) {
+						confp->wat.wat.wat_cfg.moduletype = WAT_MODULE_TELIT;
+					} else {
+						ast_log(LOG_WARNING, "Unknown WAT moduletype '%s' at line %d.\n", v->value, v->lineno);
+					}
+				} else if (!strcasecmp(v->name, "wat_timeout_cid_name")) {
+					if (atoi(v->value) >= 0) {
+						confp->wat.wat.wat_cfg.timeout_cid_num = atoi(v->value);
+					} else {
+						ast_log(LOG_WARNING, "Invalid value for '%s' at line %d.\n", v->value, v->lineno);
+					}
+				} else if (!strcasecmp(v->name, "wat_signal_poll_interval")) {
+					if (atoi(v->value) >= 0) {
+						confp->wat.wat.wat_cfg.signal_poll_interval = atoi(v->value);
+					} else {
+						ast_log(LOG_WARNING, "Invalid value for '%s' at line %d.\n", v->value, v->lineno);
+					}
+				} else if (!strcasecmp(v->name, "wat_codecs")) {
+					confp->wat.wat.wat_cfg.codec_mask = wat_encode_codec(v->value);
+#endif
 			 } else if (!strcasecmp(v->name, "outsignalling") || !strcasecmp(v->name, "outsignaling")) {
 				if (!strcasecmp(v->value, "em")) {
 					confp->chan.outsigmod = SIG_EM;
@@ -18113,6 +18728,22 @@
 		}
 	}
 #endif
+#ifdef HAVE_WAT
+	if (reload != 1) {
+		int x;
+		for (x = 0; x < NUM_SPANS; x++) {
+			if (wats[x].wat.pvt) {
+				prepare_wat(wats + x);
+				if (sig_wat_start_wat(&wats[x].wat)) {
+						ast_log(LOG_ERROR, "Unable to start sig-channel on span %d\n", x + 1);
+						return -1;
+				} else
+						ast_verb(2, "Starting signalling monitor on span %d\n", x + 1);
+			}
+		}
+	}
+#endif
+
 	/* And start the monitor for the first time */
 	restart_monitor();
 	return 0;
@@ -18347,6 +18978,13 @@
 	ss7_set_error(dahdi_ss7_error);
 	ss7_set_message(dahdi_ss7_message);
 #endif	/* defined(HAVE_SS7) */
+#ifdef HAVE_WAT
+	sig_wat_load(NUM_SPANS);
+	memset(wats, 0, sizeof(wats));
+	for (y = 0; y < NUM_SPANS; y++) {
+		sig_wat_init_wat(&wats[y].wat);
+	}
+#endif
 	res = setup_dahdi(0);
 	/* Make sure we can register our DAHDI channel type */
 	if (res)
@@ -18362,11 +19000,14 @@
 #if defined(HAVE_SS7)
 	ast_cli_register_multiple(dahdi_ss7_cli, ARRAY_LEN(dahdi_ss7_cli));
 #endif	/* defined(HAVE_SS7) */
+#ifdef HAVE_WAT
+	ast_cli_register_multiple(dahdi_wat_cli, ARRAY_LEN(dahdi_wat_cli));
+#endif
 #ifdef HAVE_OPENR2
 	ast_cli_register_multiple(dahdi_mfcr2_cli, ARRAY_LEN(dahdi_mfcr2_cli));
 	ast_register_application_xml(dahdi_accept_r2_call_app, dahdi_accept_r2_call_exec);
 #endif
-
+	
 	ast_cli_register_multiple(dahdi_cli, ARRAY_LEN(dahdi_cli));
 	/* register all the data providers */
 	ast_data_register_multiple(dahdi_data_providers, ARRAY_LEN(dahdi_data_providers));
diff -dur --exclude=configure --new-file asterisk-1.8.7.1/channels/Makefile asterisk-1.8.7.1.patched/channels/Makefile
--- asterisk-1.8.7.1/channels/Makefile	2010-06-07 16:04:42.000000000 -0400
+++ asterisk-1.8.7.1.patched/channels/Makefile	2011-12-05 17:32:01.000000000 -0500
@@ -73,8 +73,8 @@
 iax2-parser.o iax2-provision.o: _ASTCFLAGS+=$(call MOD_ASTCFLAGS,chan_iax2)
 $(if $(filter chan_sip,$(EMBEDDED_MODS)),modules.link,chan_sip.so): $(subst .c,.o,$(wildcard sip/*.c))
 $(subst .c,.o,$(wildcard sip/*.c)): _ASTCFLAGS+=$(call MOD_ASTCFLAGS,chan_sip)
-$(if $(filter chan_dahdi,$(EMBEDDED_MODS)),modules.link,chan_dahdi.so): sig_analog.o sig_pri.o sig_ss7.o
-sig_analog.o sig_pri.o sig_ss7.o: _ASTCFLAGS+=$(call MOD_ASTCFLAGS,chan_dahdi)
+$(if $(filter chan_dahdi,$(EMBEDDED_MODS)),modules.link,chan_dahdi.so): sig_analog.o sig_pri.o sig_ss7.o sig_wat.o
+sig_analog.o sig_pri.o sig_ss7.o sig_wat.o: _ASTCFLAGS+=$(call MOD_ASTCFLAGS,chan_dahdi)
 
 ifneq ($(filter chan_h323,$(EMBEDDED_MODS)),)
 modules.link: h323/libchanh323.a
diff -dur --exclude=configure --new-file asterisk-1.8.7.1/channels/sig_wat.c asterisk-1.8.7.1.patched/channels/sig_wat.c
--- asterisk-1.8.7.1/channels/sig_wat.c	1969-12-31 19:00:00.000000000 -0500
+++ asterisk-1.8.7.1.patched/channels/sig_wat.c	2011-12-05 17:49:41.000000000 -0500
@@ -0,0 +1,1053 @@
+/*
+ * Asterisk -- An open source telephony toolkit.
+ *
+ * Copyright (C) 1999 - 2009, Digium, Inc.
+ *
+ * Mark Spencer <markster@digium.com>
+ *
+ * See http://www.asterisk.org for more information about
+ * the Asterisk project. Please do not directly contact
+ * any of the maintainers of this project for assistance;
+ * the project provides a web site, mailing lists and IRC
+ * channels for your use.
+ *
+ * This program is free software, distributed under the terms of
+ * the GNU General Public License Version 2. See the LICENSE file
+ * at the top of the source tree.
+ */
+
+/*! \file
+ *
+ * \brief Wireless AT signaling module
+ *
+ * \author David Yat Sin <dyatsin@sangoma.com>
+ */
+
+#include "asterisk.h"
+
+#ifdef HAVE_WAT
+
+#include <errno.h>
+#include <ctype.h>
+#include <signal.h>
+
+#include "asterisk/cli.h"
+
+#include "sig_wat.h"
+
+#define SIGCHAN_NOTINALARM  (1 << 0)
+#define SIGCHAN_UP          (1 << 1)
+
+#define WAT_DEADLOCK_AVOIDANCE(p) \
+	do { \
+		sig_wat_unlock_private(p); \
+		usleep(1); \
+		sig_wat_lock_private(p); \
+} while (0)
+
+
+#define WAT_NOT_IMPL ast_log(LOG_WARNING, "Function not implemented (%s:%s:%d)\n", __FILE__, __FUNCTION__, __LINE__);
+
+void sig_wat_alarm(unsigned char span_id, wat_alarm_t alarm);
+void *sig_wat_malloc(size_t size);
+void *sig_wat_calloc(size_t nmemb, size_t size);
+void sig_wat_free(void *ptr);
+void sig_wat_log(unsigned char loglevel, char *fmt, ...);
+void sig_wat_log_span(unsigned char span_id, unsigned char loglevel, char *fmt, ...);
+void sig_wat_assert(char *message);
+int sig_wat_span_write(unsigned char span_id, void *buffer, unsigned len);
+void sig_wat_status_change(unsigned char span_id, wat_sigstatus_t status);
+
+void sig_wat_con_ind(unsigned char span_id, uint8_t call_id, wat_con_event_t *con_event);
+void sig_wat_con_sts(unsigned char span_id, uint8_t call_id, wat_con_status_t *con_status);
+void sig_wat_rel_ind(unsigned char span_id, uint8_t call_id, wat_rel_event_t *rel_event);
+void sig_wat_rel_cfm(unsigned char span_id, uint8_t call_id);
+void sig_wat_sms_ind(unsigned char span_id, wat_sms_event_t *sms_event);
+void sig_wat_sms_sts(unsigned char span_id, uint8_t sms_id, wat_sms_status_t *sms_status);
+
+static void sig_wat_handle_sigchan_exception(struct sig_wat_span *wat);
+static void sig_wat_handle_sigchan_data(struct sig_wat_span *wat);
+static void sig_wat_lock_private(struct sig_wat_chan *p);
+static void sig_wat_unlock_private(struct sig_wat_chan *p);
+static void wat_queue_control(struct sig_wat_span *wat, int subclass);
+static void sig_wat_set_dialing(struct sig_wat_chan *p, int is_dialing);
+static void sig_wat_lock_owner(struct sig_wat_span *wat);
+
+static int sig_wat_set_echocanceller(struct sig_wat_chan *p, int enable);
+static void sig_wat_open_media(struct sig_wat_chan *p);
+static struct ast_channel *sig_wat_new_ast_channel(struct sig_wat_chan *p, int state, int startpbx, int sub, const struct ast_channel *requestor);
+
+struct sig_wat_span **wat_spans;
+struct sig_wat_sms **wat_smss;
+
+void sig_wat_alarm(unsigned char span_id, wat_alarm_t alarm)
+{
+	ast_log(LOG_WARNING, "Span %d:Alarm %d", span_id, alarm);
+}
+
+void *sig_wat_malloc(size_t size)
+{
+	return ast_malloc(size);
+}
+
+void *sig_wat_calloc(size_t nmemb, size_t size)
+{
+	return ast_calloc(nmemb, size);
+}
+
+void sig_wat_free(void *ptr)
+{
+	return ast_free(ptr);
+}
+
+void sig_wat_log_span(unsigned char span_id, unsigned char loglevel, char *fmt, ...)
+	__attribute__((format (printf, 3, 0)));
+void sig_wat_log_span(unsigned char span_id, unsigned char loglevel, char *fmt, ...)
+{
+	char *data;
+	va_list ap;
+
+	va_start(ap, fmt);
+	if (vasprintf(&data, fmt, ap) == -1) {
+		ast_log(LOG_ERROR, "Failed to get arguments to log error\n");
+		return;
+	}
+	sig_wat_log(loglevel, "Span %d:%s", span_id, data);
+	free(data);
+	return;
+}
+
+void sig_wat_log(unsigned char loglevel, char *fmt, ...)
+	__attribute__((format (printf, 2, 0)));
+void sig_wat_log(unsigned char loglevel, char *fmt, ...)
+{
+	char *data;
+	va_list ap;
+
+	va_start(ap, fmt);
+	if (vasprintf(&data, fmt, ap) == -1) {
+		ast_log(LOG_ERROR, "Failed to get arguments to log error\n");
+		return;
+	}
+
+	switch(loglevel) {
+		case WAT_LOG_DEBUG:
+			ast_debug(1, "%s", data);
+			break;
+		case WAT_LOG_NOTICE:
+			ast_verb(3, "%s", data);
+			break;
+		case WAT_LOG_WARNING:
+			ast_log(LOG_WARNING, "%s", data);
+			break;
+		case WAT_LOG_INFO:
+			ast_verb(1, "%s", data);
+			break;		
+		case WAT_LOG_CRIT:
+		case WAT_LOG_ERROR:
+		default:
+			ast_log(LOG_ERROR, "%s", data);
+			break;
+	}
+	free(data);
+	return;
+}
+
+void sig_wat_assert(char *message)
+{
+	ast_log(LOG_ERROR, "%s\n", message);
+	ast_assert(0);
+	ast_backtrace();
+}
+
+int sig_wat_span_write(unsigned char span_id, void *buffer, unsigned len)
+{
+	int res;
+	struct sig_wat_span *wat = wat_spans[span_id];
+	char at_buf[len+2];
+	
+	ast_assert(wat != NULL);
+
+	memcpy(at_buf, buffer, len);
+	len += 2;
+	res = write(wat->fd, at_buf, len);
+	if (res < 0) {
+		if (errno != EAGAIN) {
+			ast_log(LOG_ERROR, "Span %d:Write failed: %s\n", wat->span, strerror(errno));
+		}
+	}
+	if (res != len) {
+		ast_log(LOG_ERROR, "Span %d:Short write %d (len:%d)\n", wat->span + 1, res, len);
+	}
+	return res;
+}
+
+void sig_wat_status_change(unsigned char span_id, wat_sigstatus_t status)
+{
+	struct sig_wat_span *wat = wat_spans[span_id];
+	
+	ast_assert(wat != NULL);
+	
+	if (status == WAT_SIGSTATUS_UP) {
+		ast_verb(2, "Span %d:Signalling up\n", wat->span + 1);
+		wat->sigchanavail |= SIGCHAN_UP;
+	} else {
+		ast_verb(2, "Span %d:Signalling down\n", wat->span + 1);
+		wat->sigchanavail &= ~SIGCHAN_UP;
+	}
+
+}
+
+void sig_wat_con_ind(unsigned char span_id, uint8_t call_id, wat_con_event_t *con_event)
+{
+	struct sig_wat_span *wat;
+	struct ast_channel *chan;
+
+
+	wat = wat_spans[span_id];
+	ast_assert(wat != NULL);
+	ast_assert(con_event->sub < WAT_CALL_SUB_INVALID);
+
+	ast_verb(3, "Span %d: Call Incoming (%s)\n",
+									wat->span + 1,
+									(con_event->sub == WAT_CALL_SUB_REAL) ? "Real":
+									(con_event->sub == WAT_CALL_SUB_CALLWAIT) ? "Call Waiting":
+									(con_event->sub == WAT_CALL_SUB_THREEWAY) ? "3-way":"Invalid");
+
+	sig_wat_lock_private(wat->pvt);
+
+	if (wat->pvt->subs[con_event->sub].allocd) {
+		ast_log(LOG_ERROR, "Span %d: Got CRING/RING but we already had a call. Dropping Call.\n", wat->span + 1);
+		sig_wat_unlock_private(wat->pvt);
+		return;
+	}
+
+	/* TODO
+	apply_plan_to_existing_number(plancallingnum, sizeof(plancallingnum), pri,
+	*/
+
+	wat->pvt->subs[con_event->sub].allocd = 1;
+	wat->pvt->subs[con_event->sub].wat_call_id = call_id;
+
+	wat->pvt->remotehangup = 0;
+
+	if (wat->pvt->use_callerid) {
+		/* TODO: Set plan etc.. properly */
+		strcpy(wat->pvt->cid_num, con_event->calling_num.digits);
+	}
+
+	if (ast_exists_extension(NULL, wat->pvt->context, "s", 1, wat->pvt->cid_num)) {
+		sig_wat_unlock_private(wat->pvt);
+		chan = sig_wat_new_ast_channel(wat->pvt, AST_STATE_RING, 0, con_event->sub, NULL);
+		sig_wat_lock_private(wat->pvt);
+		if (chan && !ast_pbx_start(chan)) {
+			ast_verb(3, "Accepting call from '%s', span %d\n", wat->pvt->cid_num, wat->span);
+			sig_wat_set_echocanceller(wat->pvt, 1);
+			sig_wat_unlock_private(wat->pvt);
+		} else {
+			ast_log(LOG_WARNING, "Unable to start PBX, span %d\n", wat->span);
+			if (chan) {
+				sig_wat_unlock_private(wat->pvt);
+				ast_hangup(chan);
+			} else {
+				wat_rel_req(span_id, call_id);
+				/* Do not clear the call yet, as we will get a wat_rel_cfm as a response */
+				sig_wat_unlock_private(wat->pvt);
+			}
+		}
+	} else {
+		ast_verb(3, "No \'s' extension in context '%s'\n", wat->pvt->context);
+		/* Do not clear the call yet, as we will get a wat_rel_cfm as a response */
+		wat_rel_req(span_id, call_id);
+		
+		sig_wat_unlock_private(wat->pvt);
+	}	
+	return;
+}
+
+void sig_wat_con_sts(unsigned char span_id, uint8_t call_id, wat_con_status_t *con_status)
+{
+	struct sig_wat_span *wat = wat_spans[span_id];
+	
+	ast_assert(wat != NULL);
+
+	ast_verb(3, "Span %d: Remote side %s\n",
+								wat->span + 1,
+								(con_status->type == WAT_CON_STATUS_TYPE_RINGING) ? "ringing":
+								(con_status->type == WAT_CON_STATUS_TYPE_ANSWER) ? "answered":
+								"Invalid");
+
+	switch(con_status->type) {
+		case WAT_CON_STATUS_TYPE_RINGING:
+			sig_wat_lock_private(wat->pvt);
+			sig_wat_set_echocanceller(wat->pvt, 1);
+			sig_wat_lock_owner(wat);
+			if (wat->pvt->owner) {
+				ast_setstate(wat->pvt->owner, AST_STATE_RINGING);
+				ast_channel_unlock(wat->pvt->owner);
+			}
+			wat_queue_control(wat, AST_CONTROL_RINGING);
+			sig_wat_unlock_private(wat->pvt);
+			break;
+		case WAT_CON_STATUS_TYPE_ANSWER:
+			sig_wat_lock_private(wat->pvt);
+			sig_wat_open_media(wat->pvt);
+			wat_queue_control(wat, AST_CONTROL_ANSWER);
+			sig_wat_set_dialing(wat->pvt, 0);
+			sig_wat_set_echocanceller(wat->pvt, 1);
+			sig_wat_unlock_private(wat->pvt);
+			break;
+	
+	}
+	return;
+}
+
+void sig_wat_rel_ind(unsigned char span_id, uint8_t call_id, wat_rel_event_t *rel_event)
+{
+	struct sig_wat_span *wat = wat_spans[span_id];
+	
+	ast_assert(wat != NULL);	
+
+	ast_verb(3, "Span %d: Call hangup requested\n", wat->span + 1);	
+
+	sig_wat_lock_private(wat->pvt);
+	if (!wat->pvt->subs[WAT_CALL_SUB_REAL].allocd) {
+		ast_log(LOG_ERROR, "Span %d: Got hangup, but there was not call.\n", wat->span + 1);
+		sig_wat_unlock_private(wat->pvt);
+		return;
+	}
+
+	if (wat->pvt->owner) {
+		wat->pvt->remotehangup = 1;
+		wat->pvt->owner->hangupcause = rel_event->cause;
+		wat->pvt->owner->_softhangup |= AST_SOFTHANGUP_DEV;
+	} else {
+		/* Proceed with the hangup even though we do not have an owner */
+		wat_rel_cfm(span_id, call_id);
+		memset(&wat->pvt->subs[WAT_CALL_SUB_REAL], 0, sizeof(wat->pvt->subs[0]));
+	}
+	
+	sig_wat_unlock_private(wat->pvt);
+	return;
+}
+
+void sig_wat_rel_cfm(unsigned char span_id, uint8_t call_id)
+{
+	struct sig_wat_span *wat = wat_spans[span_id];
+	
+	ast_assert(wat != NULL);
+
+	ast_verb(3, "Span %d: Call Release\n", wat->span + 1);
+	sig_wat_lock_private(wat->pvt);
+
+	if (!wat->pvt->subs[WAT_CALL_SUB_REAL].allocd) {
+		ast_log(LOG_ERROR, "Span %d: Got Release, but there was no call.\n", wat->span + 1);
+		sig_wat_unlock_private(wat->pvt);
+		return;
+	}
+
+	memset(&wat->pvt->subs[WAT_CALL_SUB_REAL], 0, sizeof(wat->pvt->subs[0]));
+	
+	sig_wat_unlock_private(wat->pvt);
+	return;
+}
+
+void sig_wat_sms_ind(unsigned char span_id, wat_sms_event_t *sms_event)
+{
+	struct sig_wat_span *wat = wat_spans[span_id];
+	ast_assert(wat != NULL);
+	ast_verb(3, "Span %d: SMS received\n %s\n", wat->span + 1, sms_event->message);
+}
+
+void sig_wat_sms_sts(unsigned char span_id, uint8_t sms_id, wat_sms_status_t *sms_status)
+{
+	struct sig_wat_span *wat = wat_spans[span_id];	
+	ast_assert(wat != NULL);
+	
+	if (sms_status->success) {
+		ast_verb(3, "Span %d: SMS sent OK (id:%d)\n", wat->span + 1, sms_id);
+	} else {
+		if (sms_status->error) {
+			ast_verb(3, "Span %d: Failed to send SMS cause:%s error:%s (id:%d)\n",
+													wat->span + 1,
+													wat_decode_sms_cause(sms_status->cause),
+													sms_status->error,
+													sms_id);
+		} else {
+			ast_verb(3, "Span %d: Failed to send SMS cause:%s (id:%d)\n",
+													wat->span + 1,
+													wat_decode_sms_cause(sms_status->cause),
+													sms_id);
+		}
+
+	}
+
+	sig_wat_lock_private(wat->pvt);
+	if (!wat->smss[sms_id]) {
+		ast_log(LOG_ERROR, "Span %d: Could not find record for transmitted SMS (id:%d)\n", wat->span + 1, sms_id);
+		sig_wat_unlock_private(wat->pvt);
+		return;
+	}	
+	ast_free(wat->smss[sms_id]);
+	wat->smss[sms_id] = NULL;
+	sig_wat_unlock_private(wat->pvt);
+	return;
+}
+
+int sig_wat_call(struct sig_wat_chan *p, struct ast_channel *ast, char *rdest)
+{
+	int i,j;
+	char *c;
+	
+	struct sig_wat_span *wat;
+	wat_con_event_t con_event;
+
+	wat = p->wat;
+
+	sig_wat_lock_private(wat->pvt);
+	
+	/* Find a free call ID */
+	i = 8;
+	for (j = 0; j < ARRAY_LEN(wat->pvt->subs); j++) {
+		if (wat->pvt->subs[j].allocd) {
+			if (wat->pvt->subs[j].wat_call_id == i) {
+				i++;
+				continue;
+			}
+		}
+	}
+
+	if (i >= WAT_MAX_CALLS_PER_SPAN) {
+		ast_log(LOG_ERROR, "Span :%d Failed to find a free call ID\n", p->wat->span+1);
+		sig_wat_unlock_private(wat->pvt);
+		return -1;
+	}
+
+	if (wat->pvt->subs[WAT_CALL_SUB_REAL].allocd) {
+		ast_log(LOG_ERROR, "Span %d: Got an outgoing call but we already had a call. Ignoring Call.\n", wat->span);
+		sig_wat_unlock_private(wat->pvt);
+		return -1;
+	}
+	
+	c = strchr(rdest, '/');
+	if (c) {
+		c++;
+	}
+
+	if (!c) {
+		ast_log(LOG_ERROR, "Span :%d Invalid destination\n", p->wat->span+1);
+		sig_wat_unlock_private(wat->pvt);
+		return -1;
+		
+	}
+
+	wat->pvt->subs[WAT_CALL_SUB_REAL].allocd = 1;
+	wat->pvt->subs[WAT_CALL_SUB_REAL].wat_call_id = i;
+	wat->pvt->subs[WAT_CALL_SUB_REAL].owner = ast;
+	wat->pvt->owner = ast;
+
+	wat->pvt->remotehangup = 0;
+
+	memset(&con_event, 0, sizeof(con_event));
+
+	ast_copy_string(con_event.called_num.digits, c, sizeof(con_event.called_num.digits));
+
+	wat_con_req(p->wat->wat_span_id, i, &con_event);
+	ast_setstate(ast, AST_STATE_DIALING);
+	sig_wat_unlock_private(wat->pvt);
+	return 0;
+}
+
+int sig_wat_answer(struct sig_wat_chan *p, struct ast_channel *ast)
+{
+	int res = 0;
+
+	sig_wat_open_media(p);
+	res = wat_con_cfm(p->wat->wat_span_id, p->subs[WAT_CALL_SUB_REAL].wat_call_id);
+	
+	ast_setstate(ast, AST_STATE_UP);
+	return res;
+}
+
+int sig_wat_hangup(struct sig_wat_chan *p, struct ast_channel *ast)
+{	
+	struct sig_wat_span *wat;
+	int res = 0;
+
+	wat = p->wat;
+	ast_assert(wat != NULL);
+
+	ast_verb(3, "Span %d: Call Hung up\n", wat->span + 1);
+
+	if (!wat->pvt->subs[WAT_CALL_SUB_REAL].allocd) {
+		ast_log(LOG_NOTICE, "Span %d: Call already hung-up\n", wat->span + 1);
+		return -1;
+	}
+
+	if (wat->pvt->remotehangup) {
+		wat_rel_cfm(wat->wat_span_id, wat->pvt->subs[WAT_CALL_SUB_REAL].wat_call_id);
+		memset(&wat->pvt->subs[WAT_CALL_SUB_REAL], 0, sizeof(wat->pvt->subs[0]));
+		wat->pvt->owner = NULL;
+	} else {
+		wat_rel_req(wat->wat_span_id, wat->pvt->subs[WAT_CALL_SUB_REAL].wat_call_id);
+	}
+
+	return res;
+}
+
+
+static void sig_wat_deadlock_avoidance_private(struct sig_wat_chan *p)
+{
+	if (p->calls->deadlock_avoidance_private) {
+		p->calls->deadlock_avoidance_private(p->chan_pvt);
+	} else {
+		/* Fallback to the old way if callback not present. */
+		WAT_DEADLOCK_AVOIDANCE(p);
+	}
+}
+
+/*!
+ * \internal
+ * \brief Obtain the sig_wat owner channel lock if the owner exists.
+ *
+ * \param wat WAT span control structure.
+ *
+ * \note Assumes the wat->lock is already obtained.
+ * \note Assumes the sig_wat_lock_private(wat->pvt) is already obtained.
+ *
+ * \return Nothing
+ */
+static void sig_wat_lock_owner(struct sig_wat_span *wat)
+{
+	for (;;) {
+		if (!wat->pvt->owner) {
+			/* There is no owner lock to get. */
+			break;
+		}
+		if (!ast_channel_trylock(wat->pvt->owner)) {
+			/* We got the lock */
+			break;
+		}
+		/* We must unlock the PRI to avoid the possibility of a deadlock */
+		ast_mutex_unlock(&wat->lock);
+		sig_wat_deadlock_avoidance_private(wat->pvt);
+		ast_mutex_lock(&wat->lock);
+	}
+}
+
+/*!
+ * \internal
+ * \brief Queue the given frame onto the owner channel.
+ *
+ * \param wat WAT span control structure.
+ * \param frame Frame to queue onto the owner channel.
+ *
+ * \note Assumes the wat->lock is already obtained.
+ * \note Assumes the sig_wat_lock_private(pri->pvts[chanpos]) is already obtained.
+ *
+ * \return Nothing
+ */
+
+static void wat_queue_frame(struct sig_wat_span *wat, struct ast_frame *frame)
+{
+	sig_wat_lock_owner(wat);
+	if (wat->pvt->owner) {
+		ast_queue_frame(wat->pvt->owner, frame);
+		ast_channel_unlock(wat->pvt->owner);
+	}
+}
+
+/*!
+ * \internal
+ * \brief Queue a control frame of the specified subclass onto the owner channel.
+ *
+ * \param wat WAT span control structure.
+ * \param subclass Control frame subclass to queue onto the owner channel.
+ *
+ * \note Assumes the wat->lock is already obtained.
+ * \note Assumes the sig_wat_lock_private(pri->pvts[chanpos]) is already obtained.
+ *
+ * \return Nothing
+ */
+static void wat_queue_control(struct sig_wat_span *wat, int subclass)
+{
+	struct ast_frame f = {AST_FRAME_CONTROL, };
+	struct sig_wat_chan *p = wat->pvt;
+
+	if (p->calls->queue_control) {
+		p->calls->queue_control(p->chan_pvt, subclass);
+	}
+
+	f.subclass.integer = subclass;
+	wat_queue_frame(wat, &f);
+}
+
+static void sig_wat_open_media(struct sig_wat_chan *p)
+{
+	if (p->calls->open_media) {
+		p->calls->open_media(p->chan_pvt);
+	}
+}
+
+static void sig_wat_unlock_private(struct sig_wat_chan *p)
+{
+	if (p->calls->unlock_private)
+		p->calls->unlock_private(p->chan_pvt);
+}
+
+static void sig_wat_lock_private(struct sig_wat_chan *p)
+{
+	if (p->calls->lock_private)
+		p->calls->lock_private(p->chan_pvt);
+}
+
+static void sig_wat_handle_sigchan_exception(struct sig_wat_span *wat)
+{
+	if (wat->calls->handle_sig_exception) {
+		wat->calls->handle_sig_exception(wat);
+	}
+	return;
+}
+
+static void sig_wat_set_dialing(struct sig_wat_chan *p, int is_dialing)
+{
+	if (p->calls->set_dialing) {
+		p->calls->set_dialing(p->chan_pvt, is_dialing);
+	}
+}
+
+static int sig_wat_set_echocanceller(struct sig_wat_chan *p, int enable)
+{
+	if (p->calls->set_echocanceller)
+		return p->calls->set_echocanceller(p->chan_pvt, enable);
+	else
+		return -1;
+}
+
+static void sig_wat_handle_sigchan_data(struct sig_wat_span *wat)
+{
+	char buf[1024];
+	int res;
+	
+	res = read(wat->fd, buf, sizeof(buf));
+	if (!res) {
+		if (errno != EAGAIN) {
+			ast_log(LOG_ERROR, "Span %d:Read on %d failed: %s\n", wat->span + 1, wat->fd, strerror(errno));
+			return;
+		}
+	}
+	wat_span_process_read(wat->wat_span_id, buf, res);
+	return;
+}
+
+static void *wat_sigchannel(void *vwat)
+{
+	struct sig_wat_span *wat = vwat;
+	struct pollfd fds[1];
+	int32_t next;
+	uint32_t lowest;
+	int res;
+
+	pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, NULL);
+
+	for(;;) {
+		fds[0].fd = wat->fd;
+		fds[0].events = POLLIN | POLLPRI;
+		fds[0].revents = 0;
+
+		lowest = 1000;
+
+		next = wat_span_schedule_next(wat->wat_span_id);
+		if (next < 0 || next > lowest) {
+			next = lowest;
+		}
+
+		pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, NULL);
+		pthread_testcancel();
+		res = poll(fds, 1, next);
+		pthread_testcancel();
+		pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, NULL);
+
+		if (res == 0) {
+			/* Timeout, do nothing */
+		} else if (res > 0) {
+			/* There is something to read */
+			if (fds[0].revents & POLLPRI) {
+				sig_wat_handle_sigchan_exception(wat);
+			}
+
+			if (fds[0].revents & POLLIN) {
+				sig_wat_handle_sigchan_data(wat);
+			}
+		} else if (errno != EINTR) {
+			ast_log(LOG_WARNING, "poll returned error %d (%s)\n", errno, strerror(errno));
+		}
+
+		wat_span_run(wat->wat_span_id);
+	}
+	/* Never reached */
+	return NULL;
+}
+
+static void wat_set_new_owner(struct sig_wat_chan *p, struct ast_channel *new_owner)
+{
+	p->owner = new_owner;
+	if (p->calls->set_new_owner) {
+		p->calls->set_new_owner(p->chan_pvt, new_owner);
+	}
+}
+
+static struct ast_channel *sig_wat_new_ast_channel(struct sig_wat_chan *p, int state, int startpbx, int sub, const struct ast_channel *requestor)
+{
+	struct ast_channel *c;
+	if (p->calls->new_ast_channel) {
+		c = p->calls->new_ast_channel(p->chan_pvt, state, startpbx, sub, requestor);
+	} else {
+		return NULL;
+	}
+
+	if (!c) {
+		return NULL;
+	}
+
+	p->subs[sub].owner = c;
+	if (!p->owner) {
+		wat_set_new_owner(p, c);
+	}
+
+	return c;
+}
+
+int sig_wat_start_wat(struct sig_wat_span *wat)
+{
+	ast_assert(!wat_spans[wat->wat_span_id]);
+
+	wat_spans[wat->wat_span_id] = wat;
+
+	wat_span_config(wat->wat_span_id, &wat->wat_cfg);
+	wat_span_start(wat->wat_span_id);
+
+	if (ast_pthread_create_background(&wat->master, NULL, wat_sigchannel, wat)) {
+		if (wat->fd > 0) {
+			close(wat->fd);
+			wat->fd = -1;
+		}
+		ast_log(LOG_ERROR, "Span %d:Unable to spawn D-channnel:%s\n", wat->span + 1, strerror(errno));
+		return -1;
+	}
+	return 0;
+}
+
+void sig_wat_stop_wat(struct sig_wat_span *wat)
+{
+	wat_span_stop(wat->wat_span_id);
+}
+
+void sig_wat_load(int maxspans)
+{
+	wat_interface_t wat_intf;
+
+	wat_spans = malloc(maxspans * sizeof(void*));
+	memset(wat_spans, 0, maxspans * sizeof(void*));
+
+	memset(&wat_intf, 0, sizeof(wat_intf));
+
+	wat_intf.wat_span_write = sig_wat_span_write;
+	wat_intf.wat_sigstatus_change = sig_wat_status_change;
+	wat_intf.wat_log = (wat_log_func_t)sig_wat_log;
+	wat_intf.wat_log_span = (wat_log_span_func_t)sig_wat_log_span;
+	wat_intf.wat_malloc = sig_wat_malloc;
+	wat_intf.wat_calloc = sig_wat_calloc;
+	wat_intf.wat_free = sig_wat_free;
+	wat_intf.wat_assert = sig_wat_assert;
+
+	wat_intf.wat_alarm = sig_wat_alarm;
+	wat_intf.wat_con_ind = sig_wat_con_ind;
+	wat_intf.wat_con_sts = sig_wat_con_sts;
+	wat_intf.wat_rel_ind = sig_wat_rel_ind;
+	wat_intf.wat_rel_cfm = sig_wat_rel_cfm;
+	wat_intf.wat_sms_ind = sig_wat_sms_ind;
+	wat_intf.wat_sms_sts = sig_wat_sms_sts;
+
+	if (wat_register(&wat_intf)) {
+		ast_log(LOG_ERROR, "Unable to register to libwat\n");
+		return;
+	}
+	ast_verb(3, "Registered libwat\n");
+	return;	
+}
+
+void sig_wat_unload(void)
+{
+	if (wat_spans) free(wat_spans);
+}
+
+void sig_wat_init_wat(struct sig_wat_span *wat)
+{
+	memset(wat, 0, sizeof(*wat));
+	ast_mutex_init(&wat->lock);
+
+	wat->master = AST_PTHREADT_NULL;
+	wat->fd = -1;
+	return;
+}
+
+struct sig_wat_chan *sig_wat_chan_new(void *pvt_data, struct sig_wat_callback *callback, struct sig_wat_span *wat, int channo)
+{
+	struct sig_wat_chan *p;
+
+	p = ast_calloc(1, sizeof(*p));
+	if (!p) {
+		return p;
+	}
+
+	p->calls = callback;
+	p->chan_pvt = pvt_data;
+
+	p->wat = wat;
+
+	return p;
+}
+
+void wat_event_alarm(struct sig_wat_span *wat)
+{
+	wat->sigchanavail &= ~(SIGCHAN_NOTINALARM | SIGCHAN_UP);
+	return;
+}
+
+void wat_event_noalarm(struct sig_wat_span *wat)
+{
+	wat->sigchanavail |= SIGCHAN_NOTINALARM;
+	return;
+}
+
+
+static void build_span_status(char *s, size_t len, int sigchanavail)
+{
+	if (!s || len < 1) {
+		return;
+	}
+	snprintf(s, len, "%s %s",
+			(sigchanavail & SIGCHAN_NOTINALARM) ? "" : "In Alarm, ",
+			(sigchanavail & SIGCHAN_UP) ? "Up": "Down");
+}
+
+void sig_wat_cli_show_spans(int fd, int span, struct sig_wat_span *wat)
+{	
+	char status[30];
+	const wat_sim_info_t *sim_info = NULL;
+
+	build_span_status(status, sizeof(status), wat->sigchanavail);
+	
+	sim_info = wat_span_get_sim_info(wat->wat_span_id);
+	if (sim_info == NULL) {
+		ast_cli(fd, "Span %d:Failed to get SIM information\n", wat->span +1);
+	}
+
+	if (sim_info && strlen(sim_info->subscriber.digits) > 0) {
+		ast_cli(fd, "WAT span %d: %5s (%14s)\n", span, status, sim_info->subscriber.digits);
+	} else {
+		ast_cli(fd, "WAT span %d: %5s\n", span, status);
+	}
+}
+
+void sig_wat_cli_show_span(int fd, struct sig_wat_span *wat)
+{
+	char status[256];
+	const wat_chip_info_t *chip_info = NULL;
+	const wat_sim_info_t *sim_info = NULL;
+	const wat_sig_info_t *sig_info = NULL;
+	const wat_net_info_t *net_info = NULL;
+	const wat_pin_stat_t *pin_status = NULL;
+	
+	build_span_status(status, sizeof(status), wat->sigchanavail);
+
+	ast_cli(fd, "WAT span %d: %s\n", wat->span + 1, status);
+	
+	pin_status = wat_span_get_pin_info(wat->wat_span_id);
+	if (pin_status == NULL) {
+		ast_cli(fd, "Span %d:Failed to get PIN status\n", wat->span + 1);
+	} else if (*pin_status != WAT_PIN_READY) {
+		ast_cli(fd, "   PIN Error:%s\n\n", wat_decode_pin_status(*pin_status));
+	}
+	
+	net_info = wat_span_get_net_info(wat->wat_span_id);
+	if (net_info == NULL) {
+		ast_cli(fd, "Span %d:Failed to get Network information\n", wat->span +1);
+	} else {
+		ast_cli(fd, "   Status: %s\n", wat_net_stat2str(net_info->stat));
+		ast_cli(fd, "   Operator: %s\n\n", net_info->operator_name);
+	}
+
+	sig_info = wat_span_get_sig_info(wat->wat_span_id);
+	if (sig_info == NULL) {
+		ast_cli(fd, "Span %d:Failed to get Signal information\n", wat->span +1);
+	} else {
+		char dest[30];
+		ast_cli(fd, "   Signal strength: %s\n", wat_decode_rssi(dest, sig_info->rssi));
+		ast_cli(fd, "   Signal BER: %s\n\n", wat_decode_ber(sig_info->ber));
+	}
+
+	sim_info = wat_span_get_sim_info(wat->wat_span_id);
+	if (sim_info == NULL) {
+		ast_cli(fd, "Span %d:Failed to get SIM information\n", wat->span +1);
+	} else {
+		ast_cli(fd, "   Subscriber: %s type:%d plan:%d <%s> \n",
+												sim_info->subscriber.digits,
+												sim_info->subscriber.type,
+												sim_info->subscriber.plan,
+												sim_info->subscriber_type);
+		ast_cli(fd, "   IMSI: %s\n\n", sim_info->imsi);
+	}
+
+	chip_info = wat_span_get_chip_info(wat->wat_span_id);
+	if (chip_info == NULL) {
+		ast_cli(fd, "Span %d:Failed to get Chip information\n", wat->span +1);
+	} else {
+		ast_cli(fd, "   Manufacturer Name: %s\n", chip_info->manufacturer_name);
+		ast_cli(fd, "   Manufacturer ID: %s\n", chip_info->manufacturer_id);
+		ast_cli(fd, "   Revision ID: %s\n", chip_info->revision);
+		ast_cli(fd, "   Serial Number: %s\n", chip_info->serial);
+	}
+
+	return;
+}
+
+WAT_AT_CMD_RESPONSE_FUNC(sig_wat_at_response)
+{
+	int i = 0;
+	while (tokens[i]) {
+		ast_verb(1, "AT response: %s\n", tokens[i]);
+		i++;
+	}
+	return i;
+}
+
+WAT_AT_CMD_RESPONSE_FUNC(sig_wat_dtmf_response)
+{
+	struct sig_wat_span *wat = NULL;
+	int i = 0;
+	char x = 0;
+	while (tokens[i]) {
+		i++;
+	}
+
+	wat = wat_spans[span_id];
+
+	ast_assert(wat != NULL);
+
+	ast_mutex_lock(&wat->lock);
+
+	wat->dtmf_count--;
+
+	sig_wat_lock_private(wat->pvt);
+
+	if (!wat->pvt->owner || !wat->pvt->subs[WAT_CALL_SUB_REAL].allocd) {
+		goto done;
+	}
+
+	if (wat->dtmf_count) {
+		/* DTMF still pending, do not enable digit detection back again just yet */
+		goto done;
+	}
+
+	sig_wat_lock_owner(wat);
+
+	x = 1;
+	ast_channel_setoption(wat->pvt->owner, AST_OPTION_DIGIT_DETECT, &x, sizeof(char), 0);
+
+	ast_channel_unlock(wat->pvt->owner);
+
+done:
+	sig_wat_unlock_private(wat->pvt);
+
+	ast_mutex_unlock(&wat->lock);
+
+	return i;
+}
+
+void sig_wat_cli_exec_at(int fd, struct sig_wat_span *wat, const char *at_cmd)
+{
+	wat_cmd_req(wat->wat_span_id, at_cmd, sig_wat_at_response, wat);
+}
+
+void sig_wat_cli_send_sms(int fd, struct sig_wat_span *wat, const char *dest, const char *sms)
+{
+	int i;
+	struct sig_wat_sms *wat_sms;
+
+	if (strlen(sms) > WAT_MAX_SMS_SZ) {
+		ast_log(LOG_ERROR, "Span %d: SMS exceeds maximum length (len:%zd max:%d)\n", wat->span + 1, strlen(sms), WAT_MAX_SMS_SZ);
+		return;
+	}
+	
+	sig_wat_lock_private(wat->pvt);
+	
+	/* Find a free SMS Id */
+	for (i = 1; i < ARRAY_LEN(wat->smss); i++) {
+		if (!wat->smss[i]) {
+			break;
+		}
+	}
+
+	if (i >= ARRAY_LEN(wat->smss)) {
+		ast_log(LOG_ERROR, "Span :%d Failed to find a free SMS ID\n", wat->span + 1);
+		sig_wat_unlock_private(wat->pvt);
+		return;
+	}
+
+	wat_sms = ast_malloc(sizeof(*wat_sms));
+	if (!wat_sms) {
+		sig_wat_unlock_private(wat->pvt);
+		return;
+	}
+
+	wat->smss[i] = wat_sms;
+	sig_wat_unlock_private(wat->pvt);
+
+	memset(wat_sms, 0, sizeof(*wat_sms));
+
+	wat_sms->wat_sms_id = i;
+
+	wat_sms->sms_event.type = WAT_SMS_TXT;
+	wat_sms->sms_event.len = strlen(sms);
+	strncpy(wat_sms->sms_event.called_num.digits, dest, sizeof(wat_sms->sms_event.called_num.digits));
+	strncpy(wat_sms->sms_event.message, sms, sizeof(wat_sms->sms_event.message));
+
+	ast_verb(3, "Span %d: Sending sms len:%d (id:%d)\n", wat->span + 1, wat_sms->sms_event.len, wat_sms->wat_sms_id);
+	ast_verb(5, "<begin>\n%s\n<end>\n\n", wat_sms->sms_event.message);
+
+	if (wat_sms_req(wat->wat_span_id, wat_sms->wat_sms_id, &wat_sms->sms_event)) {
+		ast_verb(1, "Span %d: Failed to send sms\n", wat->span + 1);
+	}
+	return;
+}
+
+
+int sig_wat_digit_begin(struct sig_wat_chan *p, struct ast_channel *ast, char digit)
+{
+	struct sig_wat_span *wat;
+	char x = 0;
+	int count = 0;
+	char dtmf[2] = { digit, '\0' };
+
+	wat = p->wat;
+
+	ast_assert(wat != NULL);
+
+	ast_mutex_lock(&wat->lock);
+	wat->dtmf_count++;
+	count = wat->dtmf_count;
+	ast_mutex_unlock(&wat->lock);
+
+	/* Disable DTMF detection while we play DTMF because the GSM module will play back some sort of feedback tone */
+	if (count == 1) {
+		x = 0;
+		ast_channel_setoption(wat->pvt->owner, AST_OPTION_DIGIT_DETECT, &x, sizeof(char), 0);
+	}
+	wat_send_dtmf(wat->wat_span_id, wat->pvt->subs[WAT_CALL_SUB_REAL].wat_call_id, dtmf, sig_wat_dtmf_response, wat);
+
+	return 0;
+}
+
+#endif /* HAVE_WAT */
diff -dur --exclude=configure --new-file asterisk-1.8.7.1/channels/sig_wat.h asterisk-1.8.7.1.patched/channels/sig_wat.h
--- asterisk-1.8.7.1/channels/sig_wat.h	1969-12-31 19:00:00.000000000 -0500
+++ asterisk-1.8.7.1.patched/channels/sig_wat.h	2011-12-05 17:49:45.000000000 -0500
@@ -0,0 +1,199 @@
+#ifndef _SIG_WAT_H
+#define _SIG_WAT_H
+/*
+ * Asterisk -- An open source telephony toolkit.
+ *
+ * Copyright (C) 1999 - 2009, Digium, Inc.
+ *
+ * Mark Spencer <markster@digium.com>
+ *
+ * See http://www.asterisk.org for more information about
+ * the Asterisk project. Please do not directly contact
+ * any of the maintainers of this project for assistance;
+ * the project provides a web site, mailing lists and IRC
+ * channels for your use.
+ *
+ * This program is free software, distributed under the terms of
+ * the GNU General Public License Version 2. See the LICENSE file
+ * at the top of the source tree.
+ */
+
+/*! \file
+ *
+ * \brief Interface header for Wireless AT commands signaling module
+ *
+ * \author David Yat Sin <dyatsin@sangoma.com>
+ */
+
+#include "asterisk/pbx.h"
+#include "asterisk/channel.h"
+#include "asterisk/frame.h"
+#include <libwat.h>
+
+#define MAX_NUM_SMS	20	/*!< Maximum number of SMS waiting to be sent */
+
+enum sig_wat_law {
+	SIG_WAT_DEFLAW = 0,
+	SIG_WAT_ULAW,
+	SIG_WAT_ALAW
+};
+
+enum sig_wat_tone {
+	SIG_WAT_TONE_RINGTONE = 0,
+	SIG_WAT_TONE_STUTTER,
+	SIG_WAT_TONE_CONGESTION,
+	SIG_WAT_TONE_DIALTONE,
+	SIG_WAT_TONE_DIALRECALL,
+	SIG_WAT_TONE_INFO,
+	SIG_WAT_TONE_BUSY,
+};
+
+struct sig_wat_span;
+
+struct sig_wat_callback {
+	/* Unlock the private in the signalling private structure.  This is used for three way calling madness. */
+	void (* const unlock_private)(void *pvt);
+	/* Lock the private in the signalling private structure.  ... */
+	void (* const lock_private)(void *pvt);
+	/* Do deadlock avoidance for the private signaling structure lock.  */
+	void (* const deadlock_avoidance_private)(void *pvt);
+	/* Function which is called back to handle any other DTMF events that are received.  Called by analog_handle_event.  Why is this
+	* important to use, instead of just directly using events received before they are passed into the library?  Because sometimes,
+	* (CWCID) the library absorbs DTMF events received. */
+	//void (* const handle_dtmf)(void *pvt, struct ast_channel *ast, enum analog_sub analog_index, struct ast_frame **dest);
+
+	//int (* const dial_digits)(void *pvt, enum analog_sub sub, struct analog_dialoperation *dop);
+	int (* const play_tone)(void *pvt, enum sig_wat_tone tone); /* DAVIDY: Do I need this? */
+
+	int (* const set_echocanceller)(void *pvt, int enable);
+	int (* const train_echocanceller)(void *pvt);				/* DAVIDY: Do I need this? */
+	int (* const dsp_reset_and_flush_digits)(void *pvt);		/* DAVIDY: Do I need this? */
+
+	struct ast_channel * (* const new_ast_channel)(void *pvt, int state, int startpbx, int sub, const struct ast_channel *requestor);
+
+	void (* const fixup_chans)(void *old_chan, void *new_chan);	/* DAVIDY: Do I need this? */
+
+	void (* const handle_sig_exception)(struct sig_wat_span *wat);
+	void (* const set_alarm)(void *pvt, int in_alarm);
+	void (* const set_dialing)(void *pvt, int is_dialing);
+	void (* const set_digital)(void *pvt, int is_digital);
+	void (* const set_callerid)(void *pvt, const struct ast_party_caller *caller);
+	void (* const set_dnid)(void *pvt, const char *dnid);
+	void (* const set_rdnis)(void *pvt, const char *rdnis);	/* DAVIDY: Do I need this? */
+	void (* const queue_control)(void *pvt, int subclass);	/* DAVIDY: Do I need this? */
+	int (* const new_nobch_intf)(struct sig_wat_span *wat);	/* DAVIDY: Do I need this? */
+	void (* const init_config)(void *pvt, struct sig_wat_span *wat);
+	const char *(* const get_orig_dialstring)(void *pvt);
+	void (* const make_cc_dialstring)(void *pvt, char *buf, size_t buf_size);
+	void (* const update_span_devstate)(struct sig_wat_span *wat);
+
+	void (* const open_media)(void *pvt);
+
+	/*!
+	 * \brief Post an AMI B channel association event.
+	 *
+	 * \param pvt Private structure of the user of this module.
+	 * \param chan Channel associated with the private pointer
+	 *
+	 * \return Nothing
+	 */
+	void (* const ami_channel_event)(void *pvt, struct ast_channel *chan); /* DAVIDY: Do I need this? */
+
+	void (* const set_new_owner)(void *pvt, struct ast_channel *new_owner);
+
+	/*! Reference the parent module. */
+	void (*module_ref)(void);
+	/*! Unreference the parent module. */
+	void (*module_unref)(void);
+};
+
+struct sig_wat_chan;
+
+struct sig_wat_sms {
+	unsigned char wat_sms_id;
+	wat_sms_event_t sms_event;
+};
+
+struct sig_wat_subchannel {
+	struct ast_channel *owner;
+	struct ast_frame f; /* DAVIDY do I need this ? */
+	unsigned int allocd:1;
+	
+	unsigned char wat_call_id; /*!< Id used by libwat for this call */
+
+	int cid_ton;
+	char cid_num[AST_MAX_EXTENSION];
+	
+	struct sig_wat_chan *chan;
+};
+
+struct sig_wat_chan {
+	struct sig_wat_span *wat;
+	struct sig_wat_callback *calls;
+	void *chan_pvt;					/*!< Private structure of the user of this module. */
+
+	struct ast_channel *owner;			/*!< Our current active owner (if applicable) */
+
+	struct sig_wat_subchannel subs[3];	/*!< Sub-channels */
+
+	int channel;					/*!< Channel Number or CRV */
+
+	char context[AST_MAX_CONTEXT];
+	char mohinterpret[MAX_MUSICCLASS];
+	char cid_num[AST_MAX_EXTENSION];
+	char cid_name[AST_MAX_EXTENSION];
+
+	unsigned int use_callerid:1; /*< whether or not to use caller id on this channel */
+
+	unsigned int remotehangup:1; /*< If the remote side initiated hangup on this channel */
+	
+
+};
+
+struct sig_wat_span {
+	int fd;						/*!< FD for the uart channel */
+	struct sig_wat_chan *pvt;	/*!< Member channel pvt struct */
+
+	pthread_t master;			/*!< Thread of master */	
+	
+	int sigchanavail;			/*!< Whether channel is available */
+
+	int span;					/*!< span number put into user output messages */
+	int wat_span_id;			/*!< Identifier used by libwat for this span */
+
+	wat_span_config_t wat_cfg;
+
+	struct sig_wat_callback *calls;	
+
+	int dtmf_count; /*!< How many DTMF's have we enqueued */
+
+	ast_mutex_t lock;			/*!< libwat access mutex */ /* DAVIDY do I need this? */
+
+	struct sig_wat_sms *smss[MAX_NUM_SMS];
+};
+
+int sig_wat_start_wat(struct sig_wat_span *wat);
+void sig_wat_stop_wat(struct sig_wat_span *wat);
+void sig_wat_init_wat(struct sig_wat_span *wat);
+
+
+int sig_wat_call(struct sig_wat_chan *p, struct ast_channel *ast, char *rdest);
+int sig_wat_answer(struct sig_wat_chan *p, struct ast_channel *ast);
+int sig_wat_hangup(struct sig_wat_chan *p, struct ast_channel *ast);
+
+void wat_event_alarm(struct sig_wat_span *wat);
+void wat_event_noalarm(struct sig_wat_span *wat);
+
+void sig_wat_load(int maxspans);
+void sig_wat_unload(void);
+
+struct sig_wat_chan *sig_wat_chan_new(void *pvt_data, struct sig_wat_callback *callback, struct sig_wat_span *wat, int channo);
+
+void sig_wat_cli_show_spans(int fd, int span, struct sig_wat_span *wat);
+void sig_wat_cli_show_span(int fd, struct sig_wat_span *wat);
+void sig_wat_cli_send_sms(int fd, struct sig_wat_span *wat, const char *dest, const char *sms);
+void sig_wat_cli_exec_at(int fd, struct sig_wat_span *wat, const char *at_cmd);
+int sig_wat_digit_begin(struct sig_wat_chan *pvt, struct ast_channel *ast, char digit);
+
+
+#endif /* _SIG_WAT_H */
diff -dur --exclude=configure --new-file asterisk-1.8.7.1/configs/chan_dahdi.conf.sample asterisk-1.8.7.1.patched/configs/chan_dahdi.conf.sample
--- asterisk-1.8.7.1/configs/chan_dahdi.conf.sample	2011-08-17 11:51:08.000000000 -0400
+++ asterisk-1.8.7.1.patched/configs/chan_dahdi.conf.sample	2011-12-05 17:50:48.000000000 -0500
@@ -92,33 +92,59 @@
 ;          Send out the specified digits as keypad digits.
 ;
 ; PRI Dialplan: The ISDN-level Type Of Number (TON) or numbering plan, used for
-; the dialed number.  For most installations, leaving this as 'unknown' (the
-; default) works in the most cases.  In some very unusual circumstances, you
-; may need to set this to 'dynamic' or 'redundant'.  Note that if you set one
-; of the others, you will be unable to dial another class of numbers.  For
-; example, if you set 'national', you will be unable to dial local or
-; international numbers.
+; the dialed number.  Leaving this as 'unknown' (the default) works for most
+; cases.  In some very unusual circumstances, you may need to set this to
+; 'dynamic' or 'redundant'.
+;
+; unknown:        Unknown
+; private:        Private ISDN
+; local:          Local ISDN
+; national:       National ISDN
+; international:  International ISDN
+; dynamic:        Dynamically selects the appropriate dialplan using the
+;                 prefix settings.
+; redundant:      Same as dynamic, except that the underlying number is not
+;                 changed (not common)
+;
+; pridialplan cannot be changed on reload.
+;pridialplan=unknown
 ;
 ; PRI Local Dialplan:  Only RARELY used for PRI (sets the calling number's
 ; numbering plan).  In North America, the typical use is sending the 10 digit
 ; callerID number and setting the prilocaldialplan to 'national' (the default).
 ; Only VERY rarely will you need to change this.
 ;
-; Neither pridialplan nor prilocaldialplan can be changed on reload.
-;
 ; unknown:        Unknown
 ; private:        Private ISDN
 ; local:          Local ISDN
 ; national:       National ISDN
 ; international:  International ISDN
-; dynamic:        Dynamically selects the appropriate dialplan
+; from_channel:   Use the CALLERID(ton) value from the channel.
+; dynamic:        Dynamically selects the appropriate dialplan using the
+;                 prefix settings.
 ; redundant:      Same as dynamic, except that the underlying number is not
 ;                 changed (not common)
 ;
-;pridialplan=unknown
+; prilocaldialplan cannot be changed on reload.
 ;prilocaldialplan=national
 ;
-; pridialplan may be also set at dialtime, by prefixing the dialled number with
+; PRI Connected Line Dialplan:  Sets the connected party number's numbering plan.
+;
+; unknown:        Unknown
+; private:        Private ISDN
+; local:          Local ISDN
+; national:       National ISDN
+; international:  International ISDN
+; from_channel:   Use the CONNECTEDLINE(ton) value from the channel.
+; dynamic:        Dynamically selects the appropriate dialplan using the
+;                 prefix settings.
+; redundant:      Same as dynamic, except that the underlying number is not
+;                 changed (not common)
+;
+; pricpndialplan cannot be changed on reload.
+;pricpndialplan=from_channel
+;
+; pridialplan may be also set at dialtime, by prefixing the dialed number with
 ; one of the following letters:
 ; U - Unknown
 ; I - International
@@ -129,7 +155,7 @@
 ; R - Reserved (should probably never be used but is included for completeness)
 ;
 ; Additionally, you may also set the following NPI bits (also by prefixing the
-; dialled string with one of the following letters):
+; dialed string with one of the following letters):
 ; u - Unknown
 ; e - E.163/E.164 (ISDN/telephony)
 ; x - X.121 (Data)
@@ -139,10 +165,11 @@
 ; r - Reserved (should probably never be used but is included for completeness)
 ;
 ; You may also set the prilocaldialplan in the same way, but by prefixing the
-; Caller*ID Number, rather than the dialled number.  Please note that telcos
-; which require this kind of additional manipulation of the TON/NPI are *rare*.
-; Most telco PRIs will work fine simply by setting pridialplan to unknown or
-; dynamic.
+; Caller*ID Number rather than the dialed number.
+
+; Please note that telcos which require this kind of additional manipulation
+; of the TON/NPI are *rare*.  Most telco PRIs will work fine simply by
+; setting pridialplan to unknown or dynamic.
 ;
 ;
 ; PRI caller ID prefixes based on the given TON/NPI (dialplan)
@@ -178,7 +205,50 @@
 ; yes or both: both directions
 ;
 ;overlapdial=yes
+
+; Send/receive ISDN display IE options.  The display options are a comma separated
+; list of the following options:
+;
+; block:        Do not pass display text data.
+;               Q.SIG: Default for send/receive.
+;               ETSI CPE: Default for send.
+; name_initial: Use display text in SETUP/CONNECT messages as the party name.
+;               Default for all other modes.
+; name_update:  Use display text in other messages (NOTIFY/FACILITY) for COLP name
+;               update.
+; name:         Combined name_initial and name_update options.
+; text:         Pass any unused display text data as an arbitrary display message
+;               during a call.  Sent text goes out in an INFORMATION message.
+;
+; * Default is an empty string for legacy behavior.
+; * The name options are not recommended for Q.SIG since Q.SIG already
+;   supports names.
+; * The send block is the only recommended setting for CPE mode since Q.931 uses
+;   the display IE only in the network to user direction.
+;
+; display_send and display_receive cannot be changed on reload.
+;
+;display_send=
+;display_receive=
+
+; Allow sending an ISDN Malicious Caller ID (MCID) request on this span.
+; Default disabled
+;
+;mcid_send=yes
+
+; Send ISDN date/time IE in CONNECT message option.  Only valid on NT spans.
+;
+; no:           Do not send date/time IE in CONNECT message.
+; date:         Send date only.
+; date_hh       Send date and hour.
+; date_hhmm     Send date, hour, and minute.
+; date_hhmmss   Send date, hour, minute, and second.
+;
+; Default is an empty string which lets libpri pick the default
+; date/time IE send policy.
 ;
+;datetime_send=
+
 ; Allow inband audio (progress) when a call is DISCONNECTed by the far end of a PRI
 ;
 ;inbanddisconnect=yes
@@ -351,6 +421,7 @@
 ; e911:           E911 (MF) style signalling
 ; ss7:            Signalling System 7
 ; mfcr2:          MFC/R2 Signalling. To specify the country variant see 'mfcr2_variant'
+; gsm:            GSM Signalling. To specify module type, see gsm_moduletype
 ;
 ; The following are used for Radio interfaces:
 ; fxs_rx:         Receive audio/COR on an FXS kewlstart interface (FXO at the
@@ -535,13 +606,28 @@
 ; Allow incoming ISDN call waiting calls.
 ; A call waiting call is a SETUP message with no B channel selected.
 ;allow_call_waiting_calls=no
-;
+
 ; Configure the ISDN span to indicate MWI for the list of mailboxes.
 ; You can give a comma separated list of up to 8 mailboxes per span.
 ; An empty list disables MWI.
 ; The default is an empty list.
 ;mwi_mailboxes=mailbox_number[@context]{,mailbox_number[@context]}
 ;
+; Configure the ISDN span voicemail numbers for MWI mailboxes.  What number
+; to call for a user to retrieve voicemail messages.
+;
+; You can give a comma separated list of numbers.  The position of the number
+; corresponds to the position in mwi_mailboxes.  If a position is empty then
+; the last number is reused.
+;
+; For example:
+;  mwi_vm_numbers=700,,800,,900
+; is equivalent to:
+;  mwi_vm_numbers=700,700,800,800,900
+;
+; The default is no number.
+;mwi_vm_numbers=
+
 ; Whether or not restrict outgoing caller ID (will be sent as ANI only, not
 ; available for the user)
 ; Mostly use with FXS ports
@@ -781,6 +867,11 @@
 ;
 ;useincomingcalleridondahditransfer = yes
 ;
+; Add a description for the channel which can be shown through the Asterisk
+; console  when executing the 'dahdi show channels' command is run.
+;
+;description=Phone located in lobby
+;
 ; AMA flags affects the recording of Call Detail Records.  If specified
 ; it may be 'default', 'omit', 'billing', or 'documentation'.
 ;
@@ -920,15 +1011,22 @@
 ;
 ;faxbuffers=>6,full
 ;
+; This option specifies what to do when the channel's bridged peer puts the
+; ISDN channel on hold.  Settable per logical ISDN span.
+; moh:          Generate music-on-hold to the remote party.
+; notify:       Send hold notification signaling to the remote party.
+;               For ETSI PTP and ETSI PTMP NT links.
+;               (The notify setting deprecates the mohinterpret=passthrough setting.)
+; hold:         Use HOLD/RETRIEVE signaling to release the B channel while on hold.
+;               For ETSI PTMP TE links.
+;
+;moh_signaling=moh
+;
 ; This option specifies a preference for which music on hold class this channel
 ; should listen to when put on hold if the music class has not been set on the
 ; channel with Set(CHANNEL(musicclass)=whatever) in the dialplan, and the peer
 ; channel putting this one on hold did not suggest a music class.
 ;
-; If this option is set to "passthrough", then the hold message will always be
-; passed through as signalling instead of generating hold music locally. This
-; setting is only valid when used on a channel that uses digital signalling.
-;
 ; This option may be set globally or on a per-channel basis.
 ;
 ;mohinterpret=default
@@ -1022,10 +1120,13 @@
 ;
 ;
 ;callerid="Green Phone"<(256) 428-6121>
+;description=Reception Phone			; add a description for 'dahdi show channels'
 ;channel => 1
 ;callerid="Black Phone"<(256) 428-6122>
+;description=Courtesy Phone
 ;channel => 2
 ;callerid="CallerID Phone" <(630) 372-1564>
+;description=					; reset the description for following channels
 ;channel => 3
 ;callerid="Pac Tel Phone" <(256) 428-6124>
 ;channel => 4
@@ -1365,6 +1466,39 @@
 
 ; ---------------- END of options to be used with signalling=mfcr2
 
+
+; ---------------- Options for use with signalling=gsm --------------
+; GSM module type. This depends on the manufacturer and model of the GSM module.
+; some valid values are:
+; telit (tested with Telit GE864-QUAD V2)
+;
+; example:
+; wat_moduletype=telit
+
+; Caller ID Name Timeout. This is the amount of time (in milliseconds) we will wait for the Caller ID Name to be
+; received on incoming calls, before notifying Asterisk of the incoming call. If we receive the
+; Caller ID Name after the call has been forwarded to Asterisk, the Caller ID Name will not be
+; accessible from Asterisk for that call.
+; wat_timeout_cid_name=500
+
+; Signal Strength Poll Interval. This will adjust the frequency at which the Line Signal Strength is monitored. The value of the
+; signal strength will then be printed in the logs for debugging. If you are seeing dropped calls and suspect poor signal quality
+; decrease this value to see if the signal quality dropped right before a dropped call.
+; wat_signal_poll_interval=5000
+
+; Codec. This sets the list of codec to be used during voice calls.
+; some valid values are:
+; all
+; full-rate
+; enhanced-full-rate
+; half-rate
+; amr-full-rate
+; amr-half-rate
+;
+; example:
+; wat_codecs=full-rate,enhanced-full-rate
+; ---------------- END of options to be used with signalling=gsm ----
+
 ; Configuration Sections
 ; ~~~~~~~~~~~~~~~~~~~~~~
 ; You can also configure channels in a separate chan_dahdi.conf section. In
diff -dur --exclude=configure --new-file asterisk-1.8.7.1/configure.ac asterisk-1.8.7.1.patched/configure.ac
--- asterisk-1.8.7.1/configure.ac	2011-09-19 12:57:40.000000000 -0400
+++ asterisk-1.8.7.1.patched/configure.ac	2011-12-05 17:32:01.000000000 -0500
@@ -416,6 +416,7 @@
 AST_OPTION_ONLY([sounds-cache], [SOUNDS_CACHE_DIR], [cached sound tarfiles], [])
 AST_EXT_LIB_SETUP([SPANDSP], [SPANDSP], [spandsp])
 AST_EXT_LIB_SETUP([SS7], [ISDN SS7], [ss7])
+AST_EXT_LIB_SETUP([WAT], [GSM AT], [wat])	
 AST_EXT_LIB_SETUP([SPEEX], [Speex], [speex])
 AST_EXT_LIB_SETUP([SPEEX_PREPROCESS], [Speex preprocess routines], [speex])
 AST_EXT_LIB_SETUP([SPEEXDSP], [SpeexDSP], [speexdsp])
@@ -1803,6 +1804,7 @@
 # These features will always be present if pri_connected_line_update is available.
 AST_EXT_LIB_CHECK([PRI_PROG_W_CAUSE], [pri], [pri_progress_with_cause], [libpri.h])
 AST_EXT_LIB_CHECK([PRI_INBANDDISCONNECT], [pri], [pri_set_inbanddisconnect], [libpri.h])
+
 AST_EXT_LIB_CHECK([PRI_SERVICE_MESSAGES], [pri], [pri_maintenance_service], [libpri.h])
 AST_EXT_LIB_CHECK([PRI_REVERSE_CHARGE], [pri], [pri_sr_set_reversecharge], [libpri.h])
 # ------------------------------------^
@@ -1830,6 +1832,8 @@
 
 AST_EXT_LIB_CHECK([SS7], [ss7], [ss7_pollflags], [libss7.h])
 
+AST_EXT_LIB_CHECK([WAT], [wat], [wat_register], [libwat.h])	
+
 AST_EXT_LIB_CHECK([OPENR2], [openr2], [openr2_chan_new], [openr2.h])
 
 if test "${USE_PWLIB}" != "no"; then
diff -dur --exclude=configure --new-file asterisk-1.8.7.1/diff.txt asterisk-1.8.7.1.patched/diff.txt
--- asterisk-1.8.7.1/diff.txt	1969-12-31 19:00:00.000000000 -0500
+++ asterisk-1.8.7.1.patched/diff.txt	2011-12-05 17:32:37.000000000 -0500
@@ -0,0 +1,2189 @@
+--- ../../asterisk/channels/chan_dahdi.c	2011-12-05 16:14:21.000000000 -0500
++++ channels/chan_dahdi.c	2011-12-05 17:32:01.000000000 -0500
+@@ -38,19 +38,19 @@
+  */
+ 
+ /*** MODULEINFO
+-	<use type="module">res_smdi</use>
++	<use>res_smdi</use>
+ 	<depend>dahdi</depend>
+ 	<depend>tonezone</depend>
+-	<use type="external">pri</use>
+-	<use type="external">ss7</use>
+-	<use type="external">openr2</use>
+-	<use type="external">wat</use>
++	<use>pri</use>
++	<use>ss7</use>
++	<use>openr2</use>
++	<use>wat</use>
+ 	<support_level>core</support_level>
+  ***/
+ 
+ #include "asterisk.h"
+ 
+-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 335853 $")
++ASTERISK_FILE_VERSION(__FILE__, "$Revision: 336635 $")
+ 
+ #if defined(__NetBSD__) || defined(__FreeBSD__)
+ #include <pthread.h>
+@@ -275,20 +275,6 @@
+ 			<para>Equivalent to the CLI command "dahdi restart".</para>
+ 		</description>
+ 	</manager>
+-	<manager name="PRIShowSpans" language="en_US">
+-		<synopsis>
+-			Show status of PRI spans.
+-		</synopsis>
+-		<syntax>
+-			<xi:include xpointer="xpointer(/docs/manager[@name='Login']/syntax/parameter[@name='ActionID'])" />
+-			<parameter name="Span">
+-				<para>Specify the specific span to show.  Show all spans if zero or not present.</para>
+-			</parameter>
+-		</syntax>
+-		<description>
+-			<para>Similar to the CLI command "pri show spans".</para>
+-		</description>
+-	</manager>
+  ***/
+ 
+ #define SMDI_MD_WAIT_TIMEOUT 1500 /* 1.5 seconds */
+@@ -354,12 +340,13 @@
+ 		#endif	/* defined(HAVE_PRI) || defined(HAVE_SS7) */
+ 		"MFC/R2"
+ 	#endif	/* defined(HAVE_OPENR2) */
+- #ifdef HAVE_WAT
++	#ifdef HAVE_WAT
+ 		#if defined(HAVE_PRI) || defined(HAVE_SS7) || defined (HAVE_WAT)
+-				" & "
+-		#endif	/* defined(HAVE_PRI) || defined(HAVE_SS7) || defined (HAVE_WAT) */
++		" & "
++		#endif  /* defined(HAVE_PRI) || defined(HAVE_SS7) || defined (HAVE_WAT) */
+ 		"WAT"
+ 	#endif /* HAVE_WAT */
++
+ #endif	/* defined(HAVE_PRI) || defined(HAVE_SS7) || defined(HAVE_OPENR2) */
+ ;
+ 
+@@ -384,7 +371,7 @@
+ #define SIG_BRI		(0x2000000 | DAHDI_SIG_CLEAR)
+ #define SIG_BRI_PTMP	(0X4000000 | DAHDI_SIG_CLEAR)
+ #define SIG_SS7		(0x1000000 | DAHDI_SIG_CLEAR)
+-#define SIG_GSM		(0x8000000 | DAHDI_SIG_CLEAR)
++#define SIG_GSM                (0x8000000 | DAHDI_SIG_CLEAR)
+ #define SIG_MFCR2 	DAHDI_SIG_CAS
+ #define	SIG_SF		DAHDI_SIG_SF
+ #define SIG_SFWINK 	(0x0100000 | DAHDI_SIG_SF)
+@@ -585,13 +572,6 @@
+ 	int metering_pulse_timeout;
+ 	int max_ani;
+ 	int max_dnis;
+-#if defined(OR2_LIB_INTERFACE) && OR2_LIB_INTERFACE > 2
+-	int dtmf_time_on;
+-	int dtmf_time_off;
+-#endif
+-#if defined(OR2_LIB_INTERFACE) && OR2_LIB_INTERFACE > 3
+-	int dtmf_end_timeout;
+-#endif
+ 	signed int get_ani_first:2;
+ #if defined(OR2_LIB_INTERFACE) && OR2_LIB_INTERFACE > 1
+ 	signed int skip_category_request:2;
+@@ -603,10 +583,6 @@
+ 	unsigned int forced_release:1;
+ 	unsigned int double_answer:1;
+ 	signed int immediate_accept:2;
+-#if defined(OR2_LIB_INTERFACE) && OR2_LIB_INTERFACE > 2
+-	signed int dtmf_dialing:2;
+-	signed int dtmf_detection:2;
+-#endif
+ 	char logdir[OR2_MAX_PATH];
+ 	char r2proto_file[OR2_MAX_PATH];
+ 	openr2_log_level_t loglevel;
+@@ -622,13 +598,14 @@
+ 
+ #ifdef HAVE_WAT
+ struct dahdi_wat {
+-	int sigchannel;	/*!< What channel is the UART channel on */	
++	int sigchannel; /*!< What channel is the UART channel on */
+ 	struct sig_wat_span wat;
+ };
+ 
+ static struct dahdi_wat wats[NUM_SPANS];
+ #endif
+ 
++
+ #ifdef HAVE_PRI
+ 
+ struct dahdi_pri {
+@@ -1012,10 +989,10 @@
+ 	 */
+ 	unsigned int manages_span_alarms:1;
+ 
+-#ifdef HAVE_WAT
++#if defined(HAVE_WAT)
+ 	struct sig_wat_span *wat;
+ #endif
+-	
++
+ #if defined(HAVE_PRI)
+ 	struct sig_pri_span *pri;
+ 	int logicalspan;
+@@ -1037,11 +1014,6 @@
+ 	 * \note The "context" string read in from chan_dahdi.conf
+ 	 */
+ 	char context[AST_MAX_CONTEXT];
+-	/*! 
+-	 * \brief A description for the channel configuration
+-	 * \note The "description" string read in from chan_dahdi.conf
+-	 */
+-	char description[32];
+ 	/*!
+ 	 * \brief Saved context string.
+ 	 */
+@@ -1178,10 +1150,15 @@
+ 	 */
+ 	int busycount;
+ 	/*!
+-	 * \brief Busy cadence pattern description.
+-	 * \note Set from the "busypattern" value read from chan_dahdi.conf
++	 * \brief Length of "busy" tone on time.
++	 * \note Set from the "busypattern" value read in from chan_dahdi.conf
++	 */
++	int busy_tonelength;
++	/*!
++	 * \brief Length of "busy" tone off time.
++	 * \note Set from the "busypattern" value read in from chan_dahdi.conf
+ 	 */
+-	struct ast_dsp_busy_pattern busy_cadence;
++	int busy_quietlength;
+ 	/*!
+ 	 * \brief Bitmapped call progress detection flags. CALLPROGRESS_xxx values.
+ 	 * \note Bits set from the "callprogress" and "faxdetect" values read in from chan_dahdi.conf
+@@ -1258,8 +1235,8 @@
+ 	int mfcr2_forced_release:1;
+ 	int mfcr2_dnis_matched:1;
+ 	int mfcr2_call_accepted:1;
++	int mfcr2_progress:1;
+ 	int mfcr2_accept_on_offer:1;
+-	int mfcr2_progress_sent:1;
+ #endif
+ 	/*! \brief DTMF digit in progress.  0 when no digit in progress. */
+ 	char begindigit;
+@@ -1339,7 +1316,6 @@
+ 	MEMBER(dahdi_pvt, use_smdi, AST_DATA_BOOLEAN)				\
+ 	MEMBER(dahdi_pvt, context, AST_DATA_STRING)				\
+ 	MEMBER(dahdi_pvt, defcontext, AST_DATA_STRING)				\
+-	MEMBER(dahdi_pvt, description, AST_DATA_STRING)				\
+ 	MEMBER(dahdi_pvt, exten, AST_DATA_STRING)				\
+ 	MEMBER(dahdi_pvt, language, AST_DATA_STRING)				\
+ 	MEMBER(dahdi_pvt, mohinterpret, AST_DATA_STRING)			\
+@@ -1383,9 +1359,11 @@
+ #ifdef HAVE_OPENR2
+ 	struct dahdi_mfcr2_conf mfcr2;
+ #endif
++
+ #ifdef HAVE_WAT
+ 	struct dahdi_wat wat;
+ #endif
++
+ 	struct dahdi_params timing;
+ 	int is_sig_auto; /*!< Use channel signalling from DAHDI? */
+ 	/*! Continue configuration even if a channel is not there. */
+@@ -1432,17 +1410,15 @@
+ 		},
+ #endif
+ #ifdef HAVE_WAT
+-		.wat.wat = {
+-			.wat_cfg = {
+-				.moduletype = WAT_MODULE_TELIT,
+-				.timeout_cid_num = 500,
+-				.timeout_command = 20000,
+-				.progress_poll_interval = 750,
+-				.signal_poll_interval = 60*1000,
+-				.codec_mask = WAT_CODEC_ALL
+-			},
++		.wat.wat.wat_cfg = {
++			.moduletype = WAT_MODULE_TELIT,
++			.timeout_cid_num = 500,
++			.timeout_command = 2000,
++			.progress_poll_interval = 750,
++			.signal_poll_interval = 60*1000,
+ 		},
+ #endif
++
+ #if defined(HAVE_SS7)
+ 		.ss7.ss7 = {
+ 			.called_nai = SS7_NAI_NATIONAL,
+@@ -1471,15 +1447,6 @@
+ 			.forced_release = 0,
+ 			.double_answer = 0,
+ 			.immediate_accept = -1,
+-#if defined(OR2_LIB_INTERFACE) && OR2_LIB_INTERFACE > 2
+-			.dtmf_dialing = -1,
+-			.dtmf_detection = -1,
+-			.dtmf_time_on = OR2_DEFAULT_DTMF_ON,
+-			.dtmf_time_off = OR2_DEFAULT_DTMF_OFF,
+-#endif
+-#if defined(OR2_LIB_INTERFACE) && OR2_LIB_INTERFACE > 3
+-			.dtmf_end_timeout = -1,
+-#endif
+ 			.logdir = "",
+ 			.r2proto_file = "",
+ 			.loglevel = OR2_LOG_ERROR | OR2_LOG_WARNING,
+@@ -1545,7 +1512,7 @@
+ }
+ 
+ 
+-static struct ast_channel *dahdi_request(const char *type, struct ast_format_cap *cap, const struct ast_channel *requestor, void *data, int *cause);
++static struct ast_channel *dahdi_request(const char *type, format_t format, const struct ast_channel *requestor, void *data, int *cause);
+ static int dahdi_digit_begin(struct ast_channel *ast, char digit);
+ static int dahdi_digit_end(struct ast_channel *ast, char digit, unsigned int duration);
+ static int dahdi_sendtext(struct ast_channel *c, const char *text);
+@@ -1564,9 +1531,10 @@
+ static int dahdi_devicestate(void *data);
+ static int dahdi_cc_callback(struct ast_channel *inbound, const char *dest, ast_cc_callback_fn callback);
+ 
+-static struct ast_channel_tech dahdi_tech = {
++static const struct ast_channel_tech dahdi_tech = {
+ 	.type = "DAHDI",
+ 	.description = tdesc,
++	.capabilities = AST_FORMAT_SLINEAR | AST_FORMAT_ULAW | AST_FORMAT_ALAW,
+ 	.requester = dahdi_request,
+ 	.send_digit_begin = dahdi_digit_begin,
+ 	.send_digit_end = dahdi_digit_end,
+@@ -1778,7 +1746,6 @@
+ 	int res;
+ 	unsigned char buf[256];
+ 	int flags;
+-	struct ast_format tmpfmt;
+ 
+ 	poller.fd = p->subs[SUB_REAL].dfd;
+ 	poller.events = POLLPRI | POLLIN;
+@@ -1814,9 +1781,9 @@
+ 		}
+ 
+ 		if (p->cid_signalling == CID_SIG_V23_JP) {
+-			res = callerid_feed_jp(p->cs, buf, res, ast_format_set(&tmpfmt, AST_LAW(p), 0));
++			res = callerid_feed_jp(p->cs, buf, res, AST_LAW(p));
+ 		} else {
+-			res = callerid_feed(p->cs, buf, res, ast_format_set(&tmpfmt, AST_LAW(p), 0));
++			res = callerid_feed(p->cs, buf, res, AST_LAW(p));
+ 		}
+ 		if (res < 0) {
+ 			/*
+@@ -1834,7 +1801,7 @@
+ 			if (num)
+ 				ast_copy_string(numbuf, num, ANALOG_MAX_CID);
+ 
+-			ast_debug(1, "CallerID number: %s, name: %s, flags=%d\n", num, name, flags);
++			ast_log(LOG_DEBUG, "CallerID number: %s, name: %s, flags=%d\n", num, name, flags);
+ 			return 0;
+ 		}
+ 	}
+@@ -1985,7 +1952,6 @@
+ static int my_callwait(void *pvt)
+ {
+ 	struct dahdi_pvt *p = pvt;
+-	struct ast_format tmpfmt;
+ 	p->callwaitingrepeat = CALLWAITING_REPEAT_SAMPLES;
+ 	if (p->cidspill) {
+ 		ast_log(LOG_WARNING, "Spill already exists?!?\n");
+@@ -2002,11 +1968,11 @@
+ 	/* Silence */
+ 	memset(p->cidspill, 0x7f, 2400 + 600 + READ_SIZE * 4);
+ 	if (!p->callwaitrings && p->callwaitingcallerid) {
+-		ast_gen_cas(p->cidspill, 1, 2400 + 680, ast_format_set(&tmpfmt, AST_LAW(p), 0));
++		ast_gen_cas(p->cidspill, 1, 2400 + 680, AST_LAW(p));
+ 		p->callwaitcas = 1;
+ 		p->cidlen = 2400 + 680 + READ_SIZE * 4;
+ 	} else {
+-		ast_gen_cas(p->cidspill, 1, 2400, ast_format_set(&tmpfmt, AST_LAW(p), 0));
++		ast_gen_cas(p->cidspill, 1, 2400, AST_LAW(p));
+ 		p->callwaitcas = 0;
+ 		p->cidlen = 2400 + READ_SIZE * 4;
+ 	}
+@@ -2019,7 +1985,6 @@
+ static int my_send_callerid(void *pvt, int cwcid, struct ast_party_caller *caller)
+ {
+ 	struct dahdi_pvt *p = pvt;
+-	struct ast_format tmpfmt;
+ 
+ 	ast_debug(2, "Starting cid spill\n");
+ 
+@@ -2033,7 +1998,7 @@
+ 			p->cidlen = ast_callerid_generate(p->cidspill,
+ 				caller->id.name.str,
+ 				caller->id.number.str,
+-				ast_format_set(&tmpfmt, AST_LAW(p), 0));
++				AST_LAW(p));
+ 		} else {
+ 			ast_verb(3, "CPE supports Call Waiting Caller*ID.  Sending '%s/%s'\n",
+ 				caller->id.name.str, caller->id.number.str);
+@@ -2042,7 +2007,7 @@
+ 			p->cidlen = ast_callerid_callwaiting_generate(p->cidspill,
+ 				caller->id.name.str,
+ 				caller->id.number.str,
+-				ast_format_set(&tmpfmt, AST_LAW(p), 0));
++				AST_LAW(p));
+ 			p->cidlen += READ_SIZE * 4;
+ 		}
+ 		p->cidpos = 0;
+@@ -2390,7 +2355,7 @@
+ 	struct dahdi_pvt *p = pvt;
+ 
+ 	if (p->waitfordialtone && CANPROGRESSDETECT(p) && p->dsp) {
+-		ast_debug(1, "Defer dialing for %dms or dialtone\n", p->waitfordialtone);
++		ast_log(LOG_DEBUG, "Defer dialing for %dms or dialtone\n", p->waitfordialtone);
+ 		gettimeofday(&p->waitingfordt, NULL);
+ 		ast_setstate(ast, AST_STATE_OFFHOOK);
+ 	}
+@@ -2673,11 +2638,10 @@
+ 
+ 	if (ioctl(p->subs[SUB_REAL].dfd, DAHDI_AUDIOMODE, &audio) == -1) {
+ 		ast_log(LOG_WARNING, "Unable to set audio mode on channel %d to %d: %s\n",
+-				p->channel, audio, strerror(errno));
++							p->channel, audio, strerror(errno));
+ 	}
+-		
+-	dahdi_setlaw(p->subs[SUB_REAL].dfd, p->law_default);
+-	return dahdi_new(p, state, startpbx, dahdi_sub, p->law_default, requestor ? requestor->linkedid : "");
++
++	return dahdi_new(p, state, startpbx, dahdi_sub, DAHDI_LAW_ALAW, requestor ? requestor->linkedid : "");
+ }
+ #endif /* defined (HAVE_WAT) */
+ 
+@@ -3113,7 +3077,7 @@
+ 	index = analogsub_to_dahdisub(sub);
+ 
+ 	if (ioctl(p->subs[index].dfd, DAHDI_DIALING, &x)) {
+-		ast_debug(1, "DAHDI_DIALING ioctl failed!\n");
++		ast_log(LOG_DEBUG, "DAHDI_DIALING ioctl failed!\n");
+ 		return -1;
+ 	}
+ 
+@@ -3126,6 +3090,7 @@
+ 	return dahdi_set_hook(p->subs[ANALOG_SUB_REAL].dfd, DAHDI_ONHOOK);
+ }
+ 
++
+ #if defined(HAVE_PRI)
+ static void my_pri_fixup_chans(void *chan_old, void *chan_new)
+ {
+@@ -3460,7 +3425,6 @@
+ 	.dsp_reset_and_flush_digits = my_dsp_reset_and_flush_digits,
+ 	.lock_private = my_lock_private,
+ 	.unlock_private = my_unlock_private,
+-	.deadlock_avoidance_private = my_deadlock_avoidance_private,
+ 	.new_ast_channel = my_new_pri_ast_channel,
+ 	.fixup_chans = my_pri_fixup_chans,
+ 	.set_alarm = my_set_alarm,
+@@ -3541,13 +3505,12 @@
+ 	if (pvt->digital) {
+ 		res = set_actual_gain(dfd, 0, 0, pvt->rxdrc, pvt->txdrc, pvt->law);
+ 	} else {
+-		res = set_actual_gain(dfd, pvt->rxgain, pvt->txgain, pvt->rxdrc, pvt->txdrc,
+-							  pvt->law);
++		res = set_actual_gain(dfd, pvt->rxgain, pvt->txgain, pvt->rxdrc, pvt->txdrc, pvt->law);
+ 	}
+ 	if (res < 0) {
+ 		ast_log(LOG_WARNING, "Unable to set gains on channel %d\n", pvt->channel);
+ 	}
+-
++	
+ 	if (pvt->dsp_features && pvt->dsp) {
+ 		ast_dsp_set_features(pvt->dsp, pvt->dsp_features);
+ 		pvt->dsp_features = 0;
+@@ -3721,7 +3684,6 @@
+ {
+ 	.lock_private = my_lock_private,
+ 	.unlock_private = my_unlock_private,
+-	.deadlock_avoidance_private = my_deadlock_avoidance_private,
+ 
+ 	.set_echocanceller = my_set_echocanceller,
+ 	.set_loopback = my_ss7_set_loopback,
+@@ -4113,13 +4075,13 @@
+ 	p->mfcr2_recvd_category = category;
+ 	/* if we're not supposed to use CID, clear whatever we have */
+ 	if (!p->use_callerid) {
+-		ast_debug(1, "No CID allowed in configuration, CID is being cleared!\n");
++		ast_log(LOG_DEBUG, "No CID allowed in configuration, CID is being cleared!\n");
+ 		p->cid_num[0] = 0;
+ 		p->cid_name[0] = 0;
+ 	}
+ 	/* if we're supposed to answer immediately, clear DNIS and set 's' exten */
+ 	if (p->immediate || !openr2_context_get_max_dnis(openr2_chan_get_context(r2chan))) {
+-		ast_debug(1, "Setting exten => s because of immediate or 0 DNIS configured\n");
++		ast_log(LOG_DEBUG, "Setting exten => s because of immediate or 0 DNIS configured\n");
+ 		p->exten[0] = 's';
+ 		p->exten[1] = 0;
+ 	}
+@@ -4142,10 +4104,10 @@
+ 		ast_log(LOG_WARNING, "Unable to create PBX channel in DAHDI channel %d\n", p->channel);
+ 		dahdi_r2_disconnect_call(p, OR2_CAUSE_OUT_OF_ORDER);
+ 	} else if (p->mfcr2_charge_calls) {
+-		ast_debug(1, "Accepting MFC/R2 call with charge on chan %d\n", p->channel);
++		ast_log(LOG_DEBUG, "Accepting MFC/R2 call with charge on chan %d\n", p->channel);
+ 		openr2_chan_accept_call(r2chan, OR2_CALL_WITH_CHARGE);
+ 	} else {
+-		ast_debug(1, "Accepting MFC/R2 call with no charge on chan %d\n", p->channel);
++		ast_log(LOG_DEBUG, "Accepting MFC/R2 call with no charge on chan %d\n", p->channel);
+ 		openr2_chan_accept_call(r2chan, OR2_CALL_NO_CHARGE);
+ 	}
+ }
+@@ -4177,7 +4139,7 @@
+ 		if (!p->mfcr2_accept_on_offer) {
+ 			openr2_chan_disable_read(r2chan);
+ 			if (p->mfcr2_answer_pending) {
+-				ast_debug(1, "Answering MFC/R2 call after accepting it on chan %d\n", openr2_chan_get_number(r2chan));
++				ast_log(LOG_DEBUG, "Answering MFC/R2 call after accepting it on chan %d\n", openr2_chan_get_number(r2chan));
+ 				dahdi_r2_answer(p);
+ 			}
+ 			return;
+@@ -4211,7 +4173,7 @@
+ 
+ static void dahdi_r2_on_call_read(openr2_chan_t *r2chan, const unsigned char *buf, int buflen)
+ {
+-	/*ast_debug(1, "Read data from dahdi channel %d\n", openr2_chan_get_number(r2chan));*/
++	/*ast_log(LOG_DEBUG, "Read data from dahdi channel %d\n", openr2_chan_get_number(r2chan));*/
+ }
+ 
+ static int dahdi_r2_cause_to_ast_cause(openr2_call_disconnect_cause_t cause)
+@@ -4294,11 +4256,11 @@
+ 	case OR2_LOG_CAS_TRACE:
+ 	case OR2_LOG_DEBUG:
+ 	case OR2_LOG_EX_DEBUG:
+-		ast_debug(1, "%s", logmessage);
++		ast_log(LOG_DEBUG, "%s", logmessage);
+ 		break;
+ 	default:
+ 		ast_log(LOG_WARNING, "We should handle logging level %d here.\n", level);
+-		ast_debug(1, "%s", logmessage);
++		ast_log(LOG_DEBUG, "%s", logmessage);
+ 		break;
+ 	}
+ }
+@@ -4624,24 +4586,17 @@
+ 	if ((idx != SUB_REAL) || !pvt->owner)
+ 		goto out;
+ 
+-	switch (pvt->sig) {
+ #ifdef HAVE_PRI
++	switch (pvt->sig) {
+ 	case SIG_PRI_LIB_HANDLE_CASES:
+ 		res = sig_pri_digit_begin(pvt->sig_pvt, chan, digit);
+ 		if (!res)
+ 			goto out;
+ 		break;
+-#endif
+-#ifdef HAVE_WAT
+-	case SIG_GSM:
+-		res = sig_wat_digit_begin(pvt->sig_pvt, chan, digit);
+-		if (!res)
+-			goto out;
+-		break;
+-#endif
+ 	default:
+ 		break;
+ 	}
++#endif
+ 	if ((dtmf = digit_to_dtmfindex(digit)) == -1)
+ 		goto out;
+ 
+@@ -4691,12 +4646,6 @@
+ 		goto out;
+ 	}
+ #endif
+-#ifdef HAVE_WAT
+-	/* This means that the digit was already sent via GSM signalling */
+-	if (dahdi_sig_wat_lib_handles(pvt->sig) && !pvt->begindigit) {
+-		goto out;
+-	}
+-#endif
+ 
+ 	if (pvt->begindigit) {
+ 		x = -1;
+@@ -4821,7 +4770,7 @@
+ 	case SIG_SF_FEATDMF:
+ 		return "SF (Tone) with Feature Group D (MF)";
+ 	case SIG_SF_FEATB:
+-		return "SF (Tone) with Feature Group B (MF)";		
++		return "SF (Tone) with Feature Group B (MF)";
+ 	case SIG_GSM:
+ 		return "GSM";
+ 	case 0:
+@@ -5415,14 +5364,12 @@
+ 
+ static int send_cwcidspill(struct dahdi_pvt *p)
+ {
+-	struct ast_format tmpfmt;
+-
+ 	p->callwaitcas = 0;
+ 	p->cidcwexpire = 0;
+ 	p->cid_suppress_expire = 0;
+ 	if (!(p->cidspill = ast_malloc(MAX_CALLERID_SIZE)))
+ 		return -1;
+-	p->cidlen = ast_callerid_callwaiting_generate(p->cidspill, p->callwait_name, p->callwait_num, ast_format_set(&tmpfmt, AST_LAW(p), 0));
++	p->cidlen = ast_callerid_callwaiting_generate(p->cidspill, p->callwait_name, p->callwait_num, AST_LAW(p));
+ 	/* Make sure we account for the end */
+ 	p->cidlen += READ_SIZE * 4;
+ 	p->cidpos = 0;
+@@ -5497,7 +5444,6 @@
+ static int dahdi_callwait(struct ast_channel *ast)
+ {
+ 	struct dahdi_pvt *p = ast->tech_pvt;
+-	struct ast_format tmpfmt;
+ 	p->callwaitingrepeat = CALLWAITING_REPEAT_SAMPLES;
+ 	if (p->cidspill) {
+ 		ast_log(LOG_WARNING, "Spill already exists?!?\n");
+@@ -5514,11 +5460,11 @@
+ 	/* Silence */
+ 	memset(p->cidspill, 0x7f, 2400 + 600 + READ_SIZE * 4);
+ 	if (!p->callwaitrings && p->callwaitingcallerid) {
+-		ast_gen_cas(p->cidspill, 1, 2400 + 680, ast_format_set(&tmpfmt, AST_LAW(p), 0));
++		ast_gen_cas(p->cidspill, 1, 2400 + 680, AST_LAW(p));
+ 		p->callwaitcas = 1;
+ 		p->cidlen = 2400 + 680 + READ_SIZE * 4;
+ 	} else {
+-		ast_gen_cas(p->cidspill, 1, 2400, ast_format_set(&tmpfmt, AST_LAW(p), 0));
++		ast_gen_cas(p->cidspill, 1, 2400, AST_LAW(p));
+ 		p->callwaitcas = 0;
+ 		p->cidlen = 2400 + READ_SIZE * 4;
+ 	}
+@@ -5532,41 +5478,11 @@
+ {
+ 	struct dahdi_pvt *p = ast->tech_pvt;
+ 	int x, res, mysig;
+-	char *dest;
+-	AST_DECLARE_APP_ARGS(args,
+-		AST_APP_ARG(group);	/* channel/group token */
+-		AST_APP_ARG(ext);	/* extension token */
+-		//AST_APP_ARG(opts);	/* options token */
+-		AST_APP_ARG(other);	/* Any remining unused arguments */
+-	);
++	char dest[256]; /* must be same length as p->dialdest */
+ 
+ 	ast_mutex_lock(&p->lock);
++	ast_copy_string(dest, rdest, sizeof(dest));
+ 	ast_copy_string(p->dialdest, rdest, sizeof(p->dialdest));
+-
+-	/* Split the dialstring */
+-	dest = ast_strdupa(rdest);
+-	AST_NONSTANDARD_APP_ARGS(args, dest, '/');
+-	if (!args.ext) {
+-		args.ext = "";
+-	}
+-
+-#if defined(HAVE_PRI)
+-	if (dahdi_sig_pri_lib_handles(p->sig)) {
+-		char *subaddr;
+-
+-		sig_pri_extract_called_num_subaddr(p->sig_pvt, rdest, p->exten, sizeof(p->exten));
+-
+-		/* Remove any subaddress for uniformity with incoming calls. */
+-		subaddr = strchr(p->exten, ':');
+-		if (subaddr) {
+-			*subaddr = '\0';
+-		}
+-	} else
+-#endif	/* defined(HAVE_PRI) */
+-	{
+-		ast_copy_string(p->exten, args.ext, sizeof(p->exten));
+-	}
+-
+ 	if ((ast->_state == AST_STATE_BUSY)) {
+ 		p->subs[SUB_REAL].needbusy = 1;
+ 		ast_mutex_unlock(&p->lock);
+@@ -5607,14 +5523,6 @@
+ 	}
+ #endif
+ 
+-#if defined(HAVE_SS7)
+-	if (p->sig == SIG_SS7) {
+-		res = sig_ss7_call(p->sig_pvt, ast, rdest);
+-		ast_mutex_unlock(&p->lock);
+-		return res;
+-	}
+-#endif	/* defined(HAVE_SS7) */
+-
+ #ifdef HAVE_WAT
+ 	if (dahdi_sig_wat_lib_handles(p->sig)) {
+ 		res = sig_wat_call(p->sig_pvt, ast, rdest);
+@@ -5623,6 +5531,14 @@
+ 	}
+ #endif
+ 
++#if defined(HAVE_SS7)
++	if (p->sig == SIG_SS7) {
++		res = sig_ss7_call(p->sig_pvt, ast, rdest);
++		ast_mutex_unlock(&p->lock);
++		return res;
++	}
++#endif	/* defined(HAVE_SS7) */
++
+ 	/* If this is analog signalling we can exit here */
+ 	if (analog_lib_handles(p->sig, p->radio, p->oprmode)) {
+ 		p->callwaitrings = 0;
+@@ -5654,7 +5570,12 @@
+ 		/* We'll get it in a moment -- but use dialdest to store pre-setup_ack digits */
+ 		p->dialdest[0] = '\0';
+ 
+-		c = args.ext;
++		c = strchr(dest, '/');
++		if (c) {
++			c++;
++		} else {
++			c = "";
++		}
+ 		if (!p->hidecallerid) {
+ 			l = ast->connected.id.number.valid ? ast->connected.id.number.str : NULL;
+ 		} else {
+@@ -5674,7 +5595,7 @@
+ 			return -1;
+ 		}
+ 		p->mfcr2_call_accepted = 0;
+-		p->mfcr2_progress_sent = 0;
++		p->mfcr2_progress = 0;
+ 		ast_setstate(ast, AST_STATE_DIALING);
+ 	}
+ #endif /* HAVE_OPENR2 */
+@@ -6134,23 +6055,23 @@
+ 	);
+ 
+ 	if (ast_strlen_zero(data)) {
+-		ast_debug(1, "No data sent to application!\n");
++		ast_log(LOG_DEBUG, "No data sent to application!\n");
+ 		return -1;
+ 	}
+ 	if (chan->tech != &dahdi_tech) {
+-		ast_debug(1, "Only DAHDI technology accepted!\n");
++		ast_log(LOG_DEBUG, "Only DAHDI technology accepted!\n");
+ 		return -1;
+ 	}
+ 	pvt = (struct dahdi_pvt *) chan->tech_pvt;
+ 	if (!pvt) {
+-		ast_debug(1, "Unable to find technology private\n");
++		ast_log(LOG_DEBUG, "Unable to find technology private\n");
+ 		return -1;
+ 	}
+ 	switch (pvt->sig) {
+ 	case SIG_PRI_LIB_HANDLE_CASES:
+ 		break;
+ 	default:
+-		ast_debug(1, "callrerouting attempted on non-ISDN channel %s\n",
++		ast_log(LOG_DEBUG, "callrerouting attempted on non-ISDN channel %s\n",
+ 			chan->name);
+ 		return -1;
+ 	}
+@@ -6197,18 +6118,18 @@
+ 	);
+ 
+ 	if (ast_strlen_zero(data)) {
+-		ast_debug(1, "No data sent to application!\n");
++		ast_log(LOG_DEBUG, "No data sent to application!\n");
+ 		return -1;
+ 	}
+ 
+ 	if (chan->tech != &dahdi_tech) {
+-		ast_debug(1, "Only DAHDI technology accepted!\n");
++		ast_log(LOG_DEBUG, "Only DAHDI technology accepted!\n");
+ 		return -1;
+ 	}
+ 
+ 	p = (struct dahdi_pvt *)chan->tech_pvt;
+ 	if (!p) {
+-		ast_debug(1, "Unable to find technology private!\n");
++		ast_log(LOG_DEBUG, "Unable to find technology private!\n");
+ 		return -1;
+ 	}
+ 
+@@ -6223,13 +6144,13 @@
+ 	ast_mutex_lock(&p->lock);
+ 	if (!p->mfcr2 || !p->mfcr2call) {
+ 		ast_mutex_unlock(&p->lock);
+-		ast_debug(1, "Channel %s does not seems to be an R2 active channel!\n", chan->name);
++		ast_log(LOG_DEBUG, "Channel %s does not seems to be an R2 active channel!\n", chan->name);
+ 		return -1;
+ 	}
+ 
+ 	if (p->mfcr2_call_accepted) {
+ 		ast_mutex_unlock(&p->lock);
+-		ast_debug(1, "MFC/R2 call already accepted on channel %s!\n", chan->name);
++		ast_log(LOG_DEBUG, "MFC/R2 call already accepted on channel %s!\n", chan->name);
+ 		return 0;
+ 	}
+ 	accept_mode = ast_true(args.charge) ? OR2_CALL_WITH_CHARGE : OR2_CALL_NO_CHARGE;
+@@ -6251,7 +6172,7 @@
+ 		}
+ 		res = ast_waitfor(chan, timeout);
+ 		if (res < 0) {
+-			ast_debug(1, "ast_waitfor failed on channel %s, going out ...\n", chan->name);
++			ast_log(LOG_DEBUG, "ast_waitfor failed on channel %s, going out ...\n", chan->name);
+ 			res = -1;
+ 			break;
+ 		}
+@@ -6260,12 +6181,12 @@
+ 		}
+ 		f = ast_read(chan);
+ 		if (!f) {
+-			ast_debug(1, "No frame read on channel %s, going out ...\n", chan->name);
++			ast_log(LOG_DEBUG, "No frame read on channel %s, going out ...\n", chan->name);
+ 			res = -1;
+ 			break;
+ 		}
+ 		if (f->frametype == AST_FRAME_CONTROL && f->subclass.integer == AST_CONTROL_HANGUP) {
+-			ast_debug(1, "Got HANGUP frame on channel %s, going out ...\n", chan->name);
++			ast_log(LOG_DEBUG, "Got HANGUP frame on channel %s, going out ...\n", chan->name);
+ 			ast_frfree(f);
+ 			res = -1;
+ 			break;
+@@ -6274,7 +6195,7 @@
+ 		ast_mutex_lock(&p->lock);
+ 		if (p->mfcr2_call_accepted) {
+ 			ast_mutex_unlock(&p->lock);
+-			ast_debug(1, "Accepted MFC/R2 call!\n");
++			ast_log(LOG_DEBUG, "Accepted MFC/R2 call!\n");
+ 			break;
+ 		}
+ 		ast_mutex_unlock(&p->lock);
+@@ -6318,7 +6239,7 @@
+ 		r2cause = OR2_CAUSE_NORMAL_CLEARING;
+ 		break;
+ 	}
+-	ast_debug(1, "ast cause %d resulted in openr2 cause %d/%s\n",
++	ast_log(LOG_DEBUG, "ast cause %d resulted in openr2 cause %d/%s\n",
+ 			cause, r2cause, openr2_proto_get_disconnect_string(r2cause));
+ 	return r2cause;
+ }
+@@ -6451,8 +6372,8 @@
+ 		p->muting = 0;
+ 		restore_gains(p);
+ 		if (p->dsp) {
+-			ast_dsp_free(p->dsp);
+-			p->dsp = NULL;
++				ast_dsp_free(p->dsp);
++				p->dsp = NULL;
+ 		}
+ 		p->ignoredtmf = 0;
+ 
+@@ -6478,7 +6399,7 @@
+ 		goto hangup_out;
+ 	}
+ #endif /* HAVE_WAT */
+-	
++
+ #if defined(HAVE_SS7)
+ 	if (p->sig == SIG_SS7) {
+ 		x = 1;
+@@ -6685,7 +6606,7 @@
+ 		/* Perform low level hangup if no owner left */
+ #ifdef HAVE_OPENR2
+ 		if (p->mfcr2 && p->mfcr2call && openr2_chan_get_direction(p->r2chan) != OR2_DIR_STOPPED) {
+-			ast_debug(1, "disconnecting MFC/R2 call on chan %d\n", p->channel);
++			ast_log(LOG_DEBUG, "disconnecting MFC/R2 call on chan %d\n", p->channel);
+ 			/* If it's an incoming call, check the mfcr2_forced_release setting */
+ 			if (openr2_chan_get_direction(p->r2chan) == OR2_DIR_BACKWARD && p->mfcr2_forced_release) {
+ 				dahdi_r2_disconnect_call(p, OR2_CAUSE_FORCED_RELEASE);
+@@ -6697,7 +6618,7 @@
+ 				dahdi_r2_disconnect_call(p, r2cause);
+ 			}
+ 		} else if (p->mfcr2call) {
+-			ast_debug(1, "Clearing call request on channel %d\n", p->channel);
++			ast_log(LOG_DEBUG, "Clearing call request on channel %d\n", p->channel);
+ 			/* since ast_request() was called but not ast_call() we have not yet dialed
+ 			and the openr2 stack will not call on_call_end callback, we need to unset
+ 			the mfcr2call flag and bump the monitor count so the monitor thread can take
+@@ -6706,9 +6627,9 @@
+ 		}
+ #endif
+ 		switch (p->sig) {
+-		case SIG_GSM:
+ 		case SIG_SS7:
+ 		case SIG_MFCR2:
++		case SIG_GSM:
+ 		case SIG_PRI_LIB_HANDLE_CASES:
+ 		case 0:
+ 			break;
+@@ -6811,7 +6732,6 @@
+ 	struct dahdi_pvt *p = ast->tech_pvt;
+ 	int res = 0;
+ 	int idx;
+-	
+ 	ast_setstate(ast, AST_STATE_UP);/*! \todo XXX this is redundantly set by the analog and PRI submodules! */
+ 	ast_mutex_lock(&p->lock);
+ 	idx = dahdi_get_index(ast, p, 0);
+@@ -6835,11 +6755,11 @@
+ 		res = sig_pri_answer(p->sig_pvt, ast);
+ 		break;
+ #endif	/* defined(HAVE_PRI) */
+-#if HAVE_WAT
++#if defined(HAVE_WAT)
+ 	case SIG_GSM:
+ 		res = sig_wat_answer(p->sig_pvt, ast);
+ 		break;
+-#endif /* HAVE_WAT */
++#endif
+ #if defined(HAVE_SS7)
+ 	case SIG_SS7:
+ 		res = sig_ss7_answer(p->sig_pvt, ast);
+@@ -6852,14 +6772,14 @@
+ 			   openr2_chan_answer_call will be called when the callback on_call_accepted is executed */
+ 			p->mfcr2_answer_pending = 1;
+ 			if (p->mfcr2_charge_calls) {
+-				ast_debug(1, "Accepting MFC/R2 call with charge before answering on chan %d\n", p->channel);
++				ast_log(LOG_DEBUG, "Accepting MFC/R2 call with charge before answering on chan %d\n", p->channel);
+ 				openr2_chan_accept_call(p->r2chan, OR2_CALL_WITH_CHARGE);
+ 			} else {
+-				ast_debug(1, "Accepting MFC/R2 call with no charge before answering on chan %d\n", p->channel);
++				ast_log(LOG_DEBUG, "Accepting MFC/R2 call with no charge before answering on chan %d\n", p->channel);
+ 				openr2_chan_accept_call(p->r2chan, OR2_CALL_NO_CHARGE);
+ 			}
+ 		} else {
+-			ast_debug(1, "Answering MFC/R2 call on chan %d\n", p->channel);
++			ast_log(LOG_DEBUG, "Answering MFC/R2 call on chan %d\n", p->channel);
+ 			dahdi_r2_answer(p);
+ 		}
+ 		break;
+@@ -7757,13 +7677,13 @@
+ 			continue;
+ 		}
+ 		f = ast_read(who);
+-		switch (f ? f->frametype : AST_FRAME_CONTROL) {
+-		case AST_FRAME_CONTROL:
++		if (!f || (f->frametype == AST_FRAME_CONTROL)) {
+ 			*fo = f;
+ 			*rc = who;
+ 			res = AST_BRIDGE_COMPLETE;
+ 			goto return_from_bridge;
+-		case AST_FRAME_DTMF_END:
++		}
++		if (f->frametype == AST_FRAME_DTMF) {
+ 			if ((who == c0) && p0->pulsedial) {
+ 				ast_write(c1, f);
+ 			} else if ((who == c1) && p1->pulsedial) {
+@@ -7774,22 +7694,6 @@
+ 				res = AST_BRIDGE_COMPLETE;
+ 				goto return_from_bridge;
+ 			}
+-			break;
+-		case AST_FRAME_TEXT:
+-			if (who == c0) {
+-				ast_write(c1, f);
+-			} else {
+-				ast_write(c0, f);
+-			}
+-			break;
+-		case AST_FRAME_VOICE:
+-			/* Native bridge handles voice frames in hardware. */
+-		case AST_FRAME_NULL:
+-			break;
+-		default:
+-			ast_debug(1, "Chan '%s' is discarding frame of frametype:%d\n",
+-				who->name, f->frametype);
+-			break;
+ 		}
+ 		ast_frfree(f);
+ 
+@@ -8210,7 +8114,7 @@
+ 		if (p->sig != SIG_MFCR2) {
+ 			ast_log(LOG_WARNING, "Received bits changed on %s signalling?\n", sig2str(p->sig));
+ 		} else {
+-			ast_debug(1, "bits changed in chan %d\n", p->channel);
++			ast_log(LOG_DEBUG, "bits changed in chan %d\n", p->channel);
+ 			openr2_chan_handle_cas(p->r2chan);
+ 		}
+ #else
+@@ -8232,7 +8136,7 @@
+ 		if (p->inalarm) break;
+ 		if ((p->radio || (p->oprmode < 0))) break;
+ 		if (ioctl(p->subs[idx].dfd,DAHDI_DIALING,&x) == -1) {
+-			ast_debug(1, "DAHDI_DIALING ioctl failed on %s: %s\n",ast->name, strerror(errno));
++			ast_log(LOG_DEBUG, "DAHDI_DIALING ioctl failed on %s: %s\n",ast->name, strerror(errno));
+ 			return NULL;
+ 		}
+ 		if (!x) { /* if not still dialing in driver */
+@@ -9190,15 +9094,15 @@
+ 	if (p->mfcr2) {
+ 		openr2_chan_process_event(p->r2chan);
+ 		if (OR2_DIR_FORWARD == openr2_chan_get_direction(p->r2chan)) {
+-			struct ast_frame fr = { AST_FRAME_CONTROL, { AST_CONTROL_PROGRESS } };
++			struct ast_frame f = { AST_FRAME_CONTROL, { AST_CONTROL_PROGRESS }, };
+ 			/* if the call is already accepted and we already delivered AST_CONTROL_RINGING
+ 			 * now enqueue a progress frame to bridge the media up */
+ 			if (p->mfcr2_call_accepted &&
+-				!p->mfcr2_progress_sent && 
+-				ast->_state == AST_STATE_RINGING) {
+-				ast_debug(1, "Enqueuing progress frame after R2 accept in chan %d\n", p->channel);
+-				ast_queue_frame(p->owner, &fr);
+-				p->mfcr2_progress_sent = 1;
++			    !p->mfcr2_progress && 
++			    ast->_state == AST_STATE_RINGING) {
++				ast_log(LOG_DEBUG, "Enqueuing progress frame after R2 accept in chan %d\n", p->channel);
++				ast_queue_frame(p->owner, &f);
++				p->mfcr2_progress = 1;
+ 			}
+ 		}
+ 	}
+@@ -9296,15 +9200,15 @@
+ 		return f;
+ 	}
+ 
+-	if (ast->rawreadformat.id == AST_FORMAT_SLINEAR) {
++	if (ast->rawreadformat == AST_FORMAT_SLINEAR) {
+ 		if (!p->subs[idx].linear) {
+ 			p->subs[idx].linear = 1;
+ 			res = dahdi_setlinear(p->subs[idx].dfd, p->subs[idx].linear);
+ 			if (res)
+ 				ast_log(LOG_WARNING, "Unable to set channel %d (index %d) to linear mode.\n", p->channel, idx);
+ 		}
+-	} else if ((ast->rawreadformat.id == AST_FORMAT_ULAW) ||
+-		(ast->rawreadformat.id == AST_FORMAT_ALAW)) {
++	} else if ((ast->rawreadformat == AST_FORMAT_ULAW) ||
++		(ast->rawreadformat == AST_FORMAT_ALAW)) {
+ 		if (p->subs[idx].linear) {
+ 			p->subs[idx].linear = 0;
+ 			res = dahdi_setlinear(p->subs[idx].dfd, p->subs[idx].linear);
+@@ -9312,7 +9216,7 @@
+ 				ast_log(LOG_WARNING, "Unable to set channel %d (index %d) to companded mode.\n", p->channel, idx);
+ 		}
+ 	} else {
+-		ast_log(LOG_WARNING, "Don't know how to read frames in format %s\n", ast_getformatname(&ast->rawreadformat));
++		ast_log(LOG_WARNING, "Don't know how to read frames in format %s\n", ast_getformatname(ast->rawreadformat));
+ 		ast_mutex_unlock(&p->lock);
+ 		return NULL;
+ 	}
+@@ -9404,7 +9308,7 @@
+ 	}
+ 
+ 	p->subs[idx].f.frametype = AST_FRAME_VOICE;
+-	ast_format_copy(&p->subs[idx].f.subclass.format, &ast->rawreadformat);
++	p->subs[idx].f.subclass.codec = ast->rawreadformat;
+ 	p->subs[idx].f.samples = READ_SIZE;
+ 	p->subs[idx].f.mallocd = 0;
+ 	p->subs[idx].f.offset = AST_FRIENDLY_OFFSET;
+@@ -9477,7 +9381,7 @@
+ 						p->waitingfordt.tv_sec = 0;
+ 						p->dsp_features &= ~DSP_FEATURE_WAITDIALTONE;
+ 						ast_dsp_set_features(p->dsp, p->dsp_features);
+-						ast_debug(1, "Got 10 samples of dialtone!\n");
++						ast_log(LOG_DEBUG, "Got 10 samples of dialtone!\n");
+ 						if (!ast_strlen_zero(p->dop.dialstr)) { /* Dial deferred digits */
+ 							res = ioctl(p->subs[SUB_REAL].dfd, DAHDI_DIAL, &p->dop);
+ 							if (res < 0) {
+@@ -9486,7 +9390,7 @@
+ 								ast_mutex_unlock(&p->lock);
+ 								return NULL;
+ 							} else {
+-								ast_debug(1, "Sent deferred digit string: %s\n", p->dop.dialstr);
++								ast_log(LOG_DEBUG, "Sent deferred digit string: %s\n", p->dop.dialstr);
+ 								p->dialing = 1;
+ 								p->dop.dialstr[0] = '\0';
+ 								p->dop.op = DAHDI_DIAL_OP_REPLACE;
+@@ -9570,10 +9474,10 @@
+ 			ast_log(LOG_WARNING, "Don't know what to do with frame type '%d'\n", frame->frametype);
+ 		return 0;
+ 	}
+-	if ((frame->subclass.format.id != AST_FORMAT_SLINEAR) &&
+-		(frame->subclass.format.id != AST_FORMAT_ULAW) &&
+-		(frame->subclass.format.id != AST_FORMAT_ALAW)) {
+-		ast_log(LOG_WARNING, "Cannot handle frames in %s format\n", ast_getformatname(&frame->subclass.format));
++	if ((frame->subclass.codec != AST_FORMAT_SLINEAR) &&
++		(frame->subclass.codec != AST_FORMAT_ULAW) &&
++		(frame->subclass.codec != AST_FORMAT_ALAW)) {
++		ast_log(LOG_WARNING, "Cannot handle frames in %s format\n", ast_getformatname(frame->subclass.codec));
+ 		return -1;
+ 	}
+ 	if (p->dialing) {
+@@ -9593,7 +9497,7 @@
+ 	if (!frame->data.ptr || !frame->datalen)
+ 		return 0;
+ 
+-	if (frame->subclass.format.id == AST_FORMAT_SLINEAR) {
++	if (frame->subclass.codec == AST_FORMAT_SLINEAR) {
+ 		if (!p->subs[idx].linear) {
+ 			p->subs[idx].linear = 1;
+ 			res = dahdi_setlinear(p->subs[idx].dfd, p->subs[idx].linear);
+@@ -9668,18 +9572,13 @@
+ 				ast_setstate(chan, AST_STATE_RINGING);
+ 			}
+ 			break;
+-		case AST_CONTROL_INCOMPLETE:
+-			ast_debug(1, "Received AST_CONTROL_INCOMPLETE on %s\n", chan->name);
+-			/* act as a progress or proceeding, allowing the caller to enter additional numbers */
+-			res = 0;
+-			break;
+ 		case AST_CONTROL_PROCEEDING:
+-			ast_debug(1, "Received AST_CONTROL_PROCEEDING on %s\n", chan->name);
++			ast_debug(1,"Received AST_CONTROL_PROCEEDING on %s\n",chan->name);
+ 			/* don't continue in ast_indicate */
+ 			res = 0;
+ 			break;
+ 		case AST_CONTROL_PROGRESS:
+-			ast_debug(1, "Received AST_CONTROL_PROGRESS on %s\n", chan->name);
++			ast_debug(1,"Received AST_CONTROL_PROGRESS on %s\n",chan->name);
+ 			/* don't continue in ast_indicate */
+ 			res = 0;
+ 			break;
+@@ -9790,7 +9689,7 @@
+ static struct ast_channel *dahdi_new(struct dahdi_pvt *i, int state, int startpbx, int idx, int law, const char *linkedid)
+ {
+ 	struct ast_channel *tmp;
+-	struct ast_format deflaw;
++	format_t deflaw;
+ 	int x;
+ 	int features;
+ 	struct ast_str *chan_name;
+@@ -9803,7 +9702,6 @@
+ 		return NULL;
+ 	}
+ 
+-	ast_format_clear(&deflaw);
+ #if defined(HAVE_PRI)
+ 	/*
+ 	 * The dnid has been stuffed with the called-number[:subaddress]
+@@ -9831,9 +9729,9 @@
+ 	if (law) {
+ 		i->law = law;
+ 		if (law == DAHDI_LAW_ALAW) {
+-			ast_format_set(&deflaw, AST_FORMAT_ALAW, 0);
++			deflaw = AST_FORMAT_ALAW;
+ 		} else {
+-			ast_format_set(&deflaw, AST_FORMAT_ULAW, 0);
++			deflaw = AST_FORMAT_ULAW;
+ 		}
+ 	} else {
+ 		switch (i->sig) {
+@@ -9847,18 +9745,18 @@
+ 			break;
+ 		}
+ 		if (i->law_default == DAHDI_LAW_ALAW) {
+-			ast_format_set(&deflaw, AST_FORMAT_ALAW, 0);
++			deflaw = AST_FORMAT_ALAW;
+ 		} else {
+-			ast_format_set(&deflaw, AST_FORMAT_ULAW, 0);
++			deflaw = AST_FORMAT_ULAW;
+ 		}
+ 	}
+ 	ast_channel_set_fd(tmp, 0, i->subs[idx].dfd);
+-	ast_format_cap_add(tmp->nativeformats, &deflaw);
++	tmp->nativeformats = deflaw;
+ 	/* Start out assuming ulaw since it's smaller :) */
+-	ast_format_copy(&tmp->rawreadformat, &deflaw);
+-	ast_format_copy(&tmp->readformat, &deflaw);
+-	ast_format_copy(&tmp->rawwriteformat, &deflaw);
+-	ast_format_copy(&tmp->writeformat, &deflaw);
++	tmp->rawreadformat = deflaw;
++	tmp->readformat = deflaw;
++	tmp->rawwriteformat = deflaw;
++	tmp->writeformat = deflaw;
+ 	i->subs[idx].linear = 0;
+ 	dahdi_setlinear(i->subs[idx].dfd, i->subs[idx].linear);
+ 	features = 0;
+@@ -9907,7 +9805,7 @@
+ 					ast_dsp_set_call_progress_zone(i->dsp, progzone);
+ 				if (i->busydetect && CANBUSYDETECT(i)) {
+ 					ast_dsp_set_busy_count(i->dsp, i->busycount);
+-					ast_dsp_set_busy_pattern(i->dsp, &i->busy_cadence);
++					ast_dsp_set_busy_pattern(i->dsp, i->busy_tonelength, i->busy_quietlength);
+ 				}
+ 			}
+ 		}
+@@ -10130,7 +10028,6 @@
+ 	int len = 0;
+ 	int res;
+ 	int idx;
+-	struct ast_format tmpfmt;
+ 
+ 	ast_mutex_lock(&ss_thread_lock);
+ 	ss_thread_count++;
+@@ -10794,9 +10691,9 @@
+ 							samples += res;
+ 
+ 							if (p->cid_signalling == CID_SIG_V23_JP) {
+-								res = callerid_feed_jp(cs, buf, res, ast_format_set(&tmpfmt, AST_LAW(p), 0));
++								res = callerid_feed_jp(cs, buf, res, AST_LAW(p));
+ 							} else {
+-								res = callerid_feed(cs, buf, res, ast_format_set(&tmpfmt, AST_LAW(p), 0));
++								res = callerid_feed(cs, buf, res, AST_LAW(p));
+ 							}
+ 							if (res < 0) {
+ 								/*
+@@ -10970,7 +10867,7 @@
+ 					f = ast_read(chan);
+ 					if (f->frametype == AST_FRAME_DTMF) {
+ 						dtmfbuf[k++] = f->subclass.integer;
+-						ast_debug(1, "CID got digit '%c'\n", f->subclass.integer);
++						ast_log(LOG_DEBUG, "CID got digit '%c'\n", f->subclass.integer);
+ 						res = 2000;
+ 					}
+ 					ast_frfree(f);
+@@ -10982,7 +10879,7 @@
+ 				dahdi_setlinear(p->subs[idx].dfd, p->subs[idx].linear);
+ 				/* Got cid and ring. */
+ 				callerid_get_dtmf(dtmfbuf, dtmfcid, &flags);
+-				ast_debug(1, "CID is '%s', flags %d\n",
++				ast_log(LOG_DEBUG, "CID is '%s', flags %d\n",
+ 					dtmfcid, flags);
+ 				/* If first byte is NULL, we have no cid */
+ 				if (!ast_strlen_zero(dtmfcid))
+@@ -11030,7 +10927,7 @@
+ 							}
+ 							/* If we get a PR event, they hung up while processing calerid */
+ 							if ( res == DAHDI_EVENT_POLARITY && p->hanguponpolarityswitch && p->polarity == POLARITY_REV) {
+-								ast_debug(1, "Hanging up due to polarity reversal on channel %d while detecting callerid\n", p->channel);
++								ast_log(LOG_DEBUG, "Hanging up due to polarity reversal on channel %d while detecting callerid\n", p->channel);
+ 								p->polarity = POLARITY_IDLE;
+ 								callerid_free(cs);
+ 								ast_hangup(chan);
+@@ -11065,7 +10962,7 @@
+ 								}
+ 							}
+ 							samples += res;
+-							res = callerid_feed(cs, buf, res, ast_format_set(&tmpfmt, AST_LAW(p), 0));
++							res = callerid_feed(cs, buf, res, AST_LAW(p));
+ 							if (res < 0) {
+ 								/*
+ 								 * The previous diagnostic message output likely
+@@ -11233,7 +11130,7 @@
+ 	size_t len;
+ };
+ 
+-static int calc_energy(const unsigned char *buf, int len, enum ast_format_id law)
++static int calc_energy(const unsigned char *buf, int len, format_t law)
+ {
+ 	int x;
+ 	int sum = 0;
+@@ -11258,7 +11155,6 @@
+ 	int i, res;
+ 	unsigned int spill_done = 0;
+ 	int spill_result = -1;
+-	struct ast_format tmpfmt;
+ 
+ 	if (!(cs = callerid_new(mtd->pvt->cid_signalling))) {
+ 		mtd->pvt->mwimonitoractive = 0;
+@@ -11266,7 +11162,7 @@
+ 		return NULL;
+ 	}
+ 
+-	callerid_feed(cs, mtd->buf, mtd->len, ast_format_set(&tmpfmt, AST_LAW(mtd->pvt), 0));
++	callerid_feed(cs, mtd->buf, mtd->len, AST_LAW(mtd->pvt));
+ 
+ 	bump_gains(mtd->pvt);
+ 
+@@ -11348,7 +11244,7 @@
+ 			}
+ 			samples += res;
+ 			if (!spill_done) {
+-				if ((spill_result = callerid_feed(cs, mtd->buf, res, ast_format_set(&tmpfmt, AST_LAW(mtd->pvt), 0))) < 0) {
++				if ((spill_result = callerid_feed(cs, mtd->buf, res, AST_LAW(mtd->pvt))) < 0) {
+ 					/*
+ 					 * The previous diagnostic message output likely
+ 					 * explains why it failed.
+@@ -11407,7 +11303,6 @@
+ static int mwi_send_init(struct dahdi_pvt * pvt)
+ {
+ 	int x;
+-	struct ast_format tmpfmt;
+ 
+ #ifdef HAVE_DAHDI_LINEREVERSE_VMWI
+ 	/* Determine how this spill is to be sent */
+@@ -11450,7 +11345,7 @@
+ 	if (pvt->mwisend_fsk) {
+ #endif
+ 		pvt->cidlen = ast_callerid_vmwi_generate(pvt->cidspill, has_voicemail(pvt), CID_MWI_TYPE_MDMF_FULL,
+-							 ast_format_set(&tmpfmt, AST_LAW(pvt), 0), pvt->cid_name, pvt->cid_num, 0);
++							 AST_LAW(pvt), pvt->cid_name, pvt->cid_num, 0);
+ 		pvt->cidpos = 0;
+ #ifdef HAVE_DAHDI_LINEREVERSE_VMWI
+ 	}
+@@ -12049,7 +11944,7 @@
+ 								pthread_attr_init(&attr);
+ 								pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
+ 
+-								ast_debug(1, "Maybe some MWI on port %d!\n", i->channel);
++								ast_log(LOG_DEBUG, "Maybe some MWI on port %d!\n", i->channel);
+ 								if ((mtd = ast_calloc(1, sizeof(*mtd)))) {
+ 									mtd->pvt = i;
+ 									memcpy(mtd->buf, buf, res);
+@@ -12356,7 +12251,7 @@
+ 		new_r2link->r2master = AST_PTHREADT_NULL;
+ 		r2links[r2links_count] = new_r2link;
+ 		r2links_count++;
+-		ast_debug(1, "Created new R2 link!\n");
++		ast_log(LOG_DEBUG, "Created new R2 link!\n");
+ 	}
+ 	return r2links[r2links_count - 1];
+ }
+@@ -12383,13 +12278,6 @@
+ 	openr2_context_set_metering_pulse_timeout(r2_link->protocol_context, conf->mfcr2.metering_pulse_timeout);
+ 	openr2_context_set_double_answer(r2_link->protocol_context, conf->mfcr2.double_answer);
+ 	openr2_context_set_immediate_accept(r2_link->protocol_context, conf->mfcr2.immediate_accept);
+-#if defined(OR2_LIB_INTERFACE) && OR2_LIB_INTERFACE > 2
+-	openr2_context_set_dtmf_dialing(r2_link->protocol_context, conf->mfcr2.dtmf_dialing, conf->mfcr2.dtmf_time_on, conf->mfcr2.dtmf_time_off);
+-	openr2_context_set_dtmf_detection(r2_link->protocol_context, conf->mfcr2.dtmf_detection);
+-#endif
+-#if defined(OR2_LIB_INTERFACE) && OR2_LIB_INTERFACE > 3
+-	openr2_context_set_dtmf_detection_end_timeout(r2_link->protocol_context, conf->mfcr2.dtmf_end_timeout);
+-#endif
+ 	if (ast_strlen_zero(conf->mfcr2.logdir)) {
+ 		if (openr2_context_set_log_directory(r2_link->protocol_context, tmplogdir)) {
+ 			ast_log(LOG_ERROR, "Failed setting default MFC/R2 log directory %s\n", tmplogdir);
+@@ -12454,7 +12342,7 @@
+ 		return -EINVAL;
+ 	}
+ 	num = minor(stbuf.st_rdev);
+-	ast_debug(1, "%s -> %d\n", path, num);
++	ast_log(LOG_DEBUG, "%s -> %d\n", path, num);
+ 	return num;
+ 
+ }
+@@ -12540,6 +12428,7 @@
+ 			tmp->vars = NULL;
+ 		}
+ 
++
+ 		if (!here) {
+ 			/* Can only get here if this is a new channel interface being created. */
+ 			if ((channel != CHAN_PSEUDO)) {
+@@ -12591,6 +12480,7 @@
+ 				}
+ 				tmp->sig_pvt = analog_p;
+ 			}
++
+ #ifdef HAVE_WAT
+ 			if (chan_sig == SIG_GSM) {
+ 				int offset;
+@@ -12598,7 +12488,7 @@
+ 				int x;
+ 
+ 				offset = (channel - p.chanpos) + 2;
+-				
++
+ 				if (ioctl(tmp->subs[SUB_REAL].dfd, DAHDI_AUDIOMODE, &offset)) {
+ 					ast_log(LOG_ERROR, "Unable to set clear mode on clear channel %d of span %d: %s\n", channel, p.spanno, strerror(errno));
+ 					destroy_dahdi_pvt(tmp);
+@@ -12639,15 +12529,14 @@
+ 						memcpy(&wats[span].wat.wat_cfg, &conf->wat.wat.wat_cfg, sizeof(wats[span].wat.wat_cfg));
+ 
+ 						wats[span].wat.pvt = tmp->sig_pvt;
+-
+ 					} else {
+-// 						ast_log(LOG_ERROR, "Channel %d is reserved for Sig-channel.\n", p.chanpos);
+ 						destroy_dahdi_pvt(tmp);
+ 						return NULL;
+ 					}
+ 				}
+ 			}
+ #endif
++
+ #if defined(HAVE_SS7)
+ 			if (chan_sig == SIG_SS7) {
+ 				struct dahdi_ss7 *ss7;
+@@ -12857,7 +12746,6 @@
+ 						pris[span].pri.nsf = conf->pri.pri.nsf;
+ 						pris[span].pri.dialplan = conf->pri.pri.dialplan;
+ 						pris[span].pri.localdialplan = conf->pri.pri.localdialplan;
+-						pris[span].pri.cpndialplan = conf->pri.pri.cpndialplan;
+ 						pris[span].pri.pvts[pris[span].pri.numchans++] = tmp->sig_pvt;
+ 						pris[span].pri.minunused = conf->pri.pri.minunused;
+ 						pris[span].pri.minidle = conf->pri.pri.minidle;
+@@ -12904,9 +12792,6 @@
+ 						ast_copy_string(pris[span].pri.mwi_mailboxes,
+ 							conf->pri.pri.mwi_mailboxes,
+ 							sizeof(pris[span].pri.mwi_mailboxes));
+-						ast_copy_string(pris[span].pri.mwi_vm_numbers,
+-							conf->pri.pri.mwi_vm_numbers,
+-							sizeof(pris[span].pri.mwi_vm_numbers));
+ #endif	/* defined(HAVE_PRI_MWI) */
+ 						ast_copy_string(pris[span].pri.idledial, conf->pri.pri.idledial, sizeof(pris[span].pri.idledial));
+ 						ast_copy_string(pris[span].pri.idleext, conf->pri.pri.idleext, sizeof(pris[span].pri.idleext));
+@@ -12915,18 +12800,7 @@
+ 						ast_copy_string(pris[span].pri.localprefix, conf->pri.pri.localprefix, sizeof(pris[span].pri.localprefix));
+ 						ast_copy_string(pris[span].pri.privateprefix, conf->pri.pri.privateprefix, sizeof(pris[span].pri.privateprefix));
+ 						ast_copy_string(pris[span].pri.unknownprefix, conf->pri.pri.unknownprefix, sizeof(pris[span].pri.unknownprefix));
+-						pris[span].pri.moh_signaling = conf->pri.pri.moh_signaling;
+ 						pris[span].pri.resetinterval = conf->pri.pri.resetinterval;
+-#if defined(HAVE_PRI_DISPLAY_TEXT)
+-						pris[span].pri.display_flags_send = conf->pri.pri.display_flags_send;
+-						pris[span].pri.display_flags_receive = conf->pri.pri.display_flags_receive;
+-#endif	/* defined(HAVE_PRI_DISPLAY_TEXT) */
+-#if defined(HAVE_PRI_MCID)
+-						pris[span].pri.mcid_send = conf->pri.pri.mcid_send;
+-#endif	/* defined(HAVE_PRI_MCID) */
+-#if defined(HAVE_PRI_DATETIME_SEND)
+-						pris[span].pri.datetime_send = conf->pri.pri.datetime_send;
+-#endif	/* defined(HAVE_PRI_DATETIME_SEND) */
+ 
+ 						for (x = 0; x < PRI_MAX_TIMERS; x++) {
+ 							pris[span].pri.pritimers[x] = conf->pri.pri.pritimers[x];
+@@ -13095,7 +12969,8 @@
+ 		}
+ 		tmp->busydetect = conf->chan.busydetect;
+ 		tmp->busycount = conf->chan.busycount;
+-		tmp->busy_cadence = conf->chan.busy_cadence;
++		tmp->busy_tonelength = conf->chan.busy_tonelength;
++		tmp->busy_quietlength = conf->chan.busy_quietlength;
+ 		tmp->callprogress = conf->chan.callprogress;
+ 		tmp->waitfordialtone = conf->chan.waitfordialtone;
+ 		tmp->cancallforward = conf->chan.cancallforward;
+@@ -13144,7 +13019,6 @@
+ 		ast_copy_string(tmp->mohinterpret, conf->chan.mohinterpret, sizeof(tmp->mohinterpret));
+ 		ast_copy_string(tmp->mohsuggest, conf->chan.mohsuggest, sizeof(tmp->mohsuggest));
+ 		ast_copy_string(tmp->context, conf->chan.context, sizeof(tmp->context));
+-		ast_copy_string(tmp->description, conf->chan.description, sizeof(tmp->description));
+ 		ast_copy_string(tmp->parkinglot, conf->chan.parkinglot, sizeof(tmp->parkinglot));
+ 		tmp->cid_ton = 0;
+ 		if (analog_lib_handles(tmp->sig, tmp->radio, tmp->oprmode)) {
+@@ -13230,6 +13104,18 @@
+ 			if ((res = get_alarms(tmp)) != DAHDI_ALARM_NONE) {
+ 				/* the dchannel is down so put the channel in alarm */
+ 				switch (tmp->sig) {
++#ifdef HAVE_WAT
++				case SIG_GSM:
++					if (wat_chan) {
++						wat_chan->channel = tmp->channel;
++						ast_copy_string(wat_chan->context, tmp->context,
++														sizeof(wat_chan->context));
++						ast_copy_string(wat_chan->mohinterpret, tmp->mohinterpret,
++														sizeof(wat_chan->mohinterpret));
++					}
++					break;
++#endif /* defined (HAVE_WAT) */
++
+ #ifdef HAVE_PRI
+ 				case SIG_PRI_LIB_HANDLE_CASES:
+ 					sig_pri_set_alarm(tmp->sig_pvt, !si.alarms);
+@@ -13310,17 +13196,6 @@
+ 		}
+ 
+ 		switch (tmp->sig) {
+-#ifdef HAVE_WAT
+-		case SIG_GSM:
+-			if (wat_chan) {
+-				wat_chan->channel = tmp->channel;
+-				ast_copy_string(wat_chan->context, tmp->context,
+-								sizeof(wat_chan->context));
+-				ast_copy_string(wat_chan->mohinterpret, tmp->mohinterpret,
+-								sizeof(wat_chan->mohinterpret));
+-			}
+-			break;
+-#endif /* defined (HAVE_WAT) */
+ #if defined(HAVE_PRI)
+ 		case SIG_PRI_LIB_HANDLE_CASES:
+ 			if (pri_chan) {
+@@ -13911,7 +13786,7 @@
+ 	return p;
+ }
+ 
+-static struct ast_channel *dahdi_request(const char *type, struct ast_format_cap *cap, const struct ast_channel *requestor, void *data, int *cause)
++static struct ast_channel *dahdi_request(const char *type, format_t format, const struct ast_channel *requestor, void *data, int *cause)
+ {
+ 	int callwait = 0;
+ 	struct dahdi_pvt *p;
+@@ -13946,7 +13821,7 @@
+ 				ast_mutex_lock(&p->lock);
+ 				if (p->mfcr2call) {
+ 					ast_mutex_unlock(&p->lock);
+-					ast_debug(1, "Yay!, someone just beat us in the race for channel %d.\n", p->channel);
++					ast_log(LOG_DEBUG, "Yay!, someone just beat us in the race for channel %d.\n", p->channel);
+ 					goto next;
+ 				}
+ 				p->mfcr2call = 1;
+@@ -14297,7 +14172,7 @@
+ 				continue;
+ 			}
+ 			if (!mfcr2->pvts[i]->r2chan) {
+-				ast_debug(1, "Wow, no r2chan on channel %d\n", mfcr2->pvts[i]->channel);
++				ast_log(LOG_DEBUG, "Wow, no r2chan on channel %d\n", mfcr2->pvts[i]->channel);
+ 				quit_loop = 1;
+ 				break;
+ 			}
+@@ -14311,7 +14186,7 @@
+ 		}
+ 		if (pollsize == 0) {
+ 			if (!was_idle) {
+-				ast_debug(1, "Monitor thread going idle since everybody has an owner\n");
++				ast_log(LOG_DEBUG, "Monitor thread going idle since everybody has an owner\n");
+ 				was_idle = 1;
+ 			}
+ 			poll(NULL, 0, maxsleep);
+@@ -14341,7 +14216,6 @@
+ }
+ #endif /* HAVE_OPENR2 */
+ 
+-
+ #ifdef HAVE_WAT
+ static int prepare_wat(struct dahdi_wat *wat)
+ {
+@@ -14393,7 +14267,8 @@
+ 	}
+ 	return 0;
+ }
+-#endif	/* HAVE_WAT */
++#endif /* HAVE_WAT */
++
+ 
+ #if defined(HAVE_PRI)
+ #ifndef PRI_RESTART
+@@ -15423,7 +15298,7 @@
+ 		}
+ 	}
+ #endif
+-	
++
+ #if defined(HAVE_WAT)
+ 	for (i = 0; i < NUM_SPANS; i++) {
+ 		if (wats[i].wat.master && (wats[i].wat.master != AST_PTHREADT_NULL)) {
+@@ -15436,6 +15311,7 @@
+ 	}
+ #endif
+ 
++
+ #if defined(HAVE_SS7)
+ 	for (i = 0; i < NUM_SPANS; i++) {
+ 		if (linksets[i].ss7.master && (linksets[i].ss7.master != AST_PTHREADT_NULL)) {
+@@ -15554,8 +15430,8 @@
+ 
+ static char *dahdi_show_channels(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)
+ {
+-#define FORMAT "%7s %-10.10s %-15.15s %-10.10s %-20.20s %-10.10s %-10.10s %-32.32s\n"
+-#define FORMAT2 "%7s %-10.10s %-15.15s %-10.10s %-20.20s %-10.10s %-10.10s %-32.32s\n"
++#define FORMAT "%7s %-10.10s %-15.15s %-10.10s %-20.20s %-10.10s %-10.10s\n"
++#define FORMAT2 "%7s %-10.10s %-15.15s %-10.10s %-20.20s %-10.10s %-10.10s\n"
+ 	unsigned int targetnum = 0;
+ 	int filtertype = 0;
+ 	struct dahdi_pvt *tmp = NULL;
+@@ -15592,7 +15468,7 @@
+ 		}
+ 	}
+ 
+-	ast_cli(a->fd, FORMAT2, "Chan", "Extension", "Context", "Language", "MOH Interpret", "Blocked", "State", "Description");
++	ast_cli(a->fd, FORMAT2, "Chan", "Extension", "Context", "Language", "MOH Interpret", "Blocked", "State");
+ 	ast_mutex_lock(&iflock);
+ 	for (tmp = iflist; tmp; tmp = tmp->next) {
+ 		if (filtertype) {
+@@ -15630,7 +15506,7 @@
+ 
+ 		snprintf(statestr, sizeof(statestr), "%s", "In Service");
+ 
+-		ast_cli(a->fd, FORMAT, tmps, tmp->exten, tmp->context, tmp->language, tmp->mohinterpret, blockstr, statestr, tmp->description);
++		ast_cli(a->fd, FORMAT, tmps, tmp->exten, tmp->context, tmp->language, tmp->mohinterpret, blockstr, statestr);
+ 	}
+ 	ast_mutex_unlock(&iflock);
+ 	return CLI_SUCCESS;
+@@ -15666,7 +15542,6 @@
+ 	for (tmp = iflist; tmp; tmp = tmp->next) {
+ 		if (tmp->channel == channel) {
+ 			ast_cli(a->fd, "Channel: %d\n", tmp->channel);
+-			ast_cli(a->fd, "Description: %s\n", tmp->description);
+ 			ast_cli(a->fd, "File Descriptor: %d\n", tmp->subs[SUB_REAL].dfd);
+ 			ast_cli(a->fd, "Span: %d\n", tmp->span);
+ 			ast_cli(a->fd, "Extension: %s\n", tmp->exten);
+@@ -15710,7 +15585,7 @@
+ 				ast_cli(a->fd, "    Busy Detector Debug: Enabled\n");
+ #endif
+ 				ast_cli(a->fd, "    Busy Count: %d\n", tmp->busycount);
+-				ast_cli(a->fd, "    Busy Pattern: %d,%d,%d,%d\n", tmp->busy_cadence.pattern[0], tmp->busy_cadence.pattern[1], (tmp->busy_cadence.length == 4) ? tmp->busy_cadence.pattern[2] : 0, (tmp->busy_cadence.length == 4) ? tmp->busy_cadence.pattern[3] : 0);
++				ast_cli(a->fd, "    Busy Pattern: %d,%d\n", tmp->busy_tonelength, tmp->busy_quietlength);
+ 			}
+ 			ast_cli(a->fd, "TDD: %s\n", tmp->tdd ? "yes" : "no");
+ 			ast_cli(a->fd, "Relax DTMF: %s\n", tmp->dtmfrelax ? "yes" : "no");
+@@ -15752,10 +15627,6 @@
+ 				ast_cli(a->fd, "MFC/R2 Variant: %s\n", openr2_proto_get_variant_string(r2variant));
+ 				ast_cli(a->fd, "MFC/R2 Max ANI: %d\n", openr2_context_get_max_ani(r2context));
+ 				ast_cli(a->fd, "MFC/R2 Max DNIS: %d\n", openr2_context_get_max_dnis(r2context));
+-#if defined(OR2_LIB_INTERFACE) && OR2_LIB_INTERFACE > 2
+-				ast_cli(a->fd, "MFC/R2 DTMF Dialing: %s\n", openr2_context_get_dtmf_dialing(r2context, NULL, NULL) ? "Yes" : "No");
+-				ast_cli(a->fd, "MFC/R2 DTMF Detection: %s\n", openr2_context_get_dtmf_detection(r2context) ? "Yes" : "No");
+-#endif
+ 				ast_cli(a->fd, "MFC/R2 Get ANI First: %s\n", openr2_context_get_ani_first(r2context) ? "Yes" : "No");
+ #if defined(OR2_LIB_INTERFACE) && OR2_LIB_INTERFACE > 1
+ 				ast_cli(a->fd, "MFC/R2 Skip Category Request: %s\n", openr2_context_get_skip_category_request(r2context) ? "Yes" : "No");
+@@ -16403,7 +16274,6 @@
+ 					"Context: %s\r\n"
+ 					"DND: %s\r\n"
+ 					"Alarm: %s\r\n"
+-					"Description: %s\r\n"
+ 					"%s"
+ 					"\r\n",
+ 					tmp->channel,
+@@ -16414,8 +16284,7 @@
+ 					tmp->sig,
+ 					tmp->context,
+ 					dahdi_dnd(tmp, -1) ? "Enabled" : "Disabled",
+-					alarm2str(alm),
+-					tmp->description, idText);
++					alarm2str(alm), idText);
+ 			} else {
+ 				astman_append(s,
+ 					"Event: DAHDIShowChannels\r\n"
+@@ -16425,14 +16294,12 @@
+ 					"Context: %s\r\n"
+ 					"DND: %s\r\n"
+ 					"Alarm: %s\r\n"
+-					"Description: %s\r\n"
+ 					"%s"
+ 					"\r\n",
+ 					tmp->channel, sig2str(tmp->sig), tmp->sig,
+ 					tmp->context,
+ 					dahdi_dnd(tmp, -1) ? "Enabled" : "Disabled",
+-					alarm2str(alm),
+-					tmp->description, idText);
++					alarm2str(alm), idText);
+ 			}
+ 		}
+ 	}
+@@ -16449,60 +16316,6 @@
+ 	return 0;
+ }
+ 
+-#if defined(HAVE_PRI)
+-static int action_prishowspans(struct mansession *s, const struct message *m)
+-{
+-	int count;
+-	int idx;
+-	int span_query;
+-	struct dahdi_pri *dspan;
+-	const char *id = astman_get_header(m, "ActionID");
+-	const char *span_str = astman_get_header(m, "Span");
+-	char action_id[256];
+-	const char *show_cmd = "PRIShowSpans";
+-
+-	/* NOTE: Asking for span 0 gets all spans. */
+-	if (!ast_strlen_zero(span_str)) {
+-		span_query = atoi(span_str);
+-	} else {
+-		span_query = 0;
+-	}
+-
+-	if (!ast_strlen_zero(id)) {
+-		snprintf(action_id, sizeof(action_id), "ActionID: %s\r\n", id);
+-	} else {
+-		action_id[0] = '\0';
+-	}
+-
+-	astman_send_ack(s, m, "Span status will follow");
+-
+-	count = 0;
+-	for (idx = 0; idx < ARRAY_LEN(pris); ++idx) {
+-		dspan = &pris[idx];
+-
+-		/* If a specific span is asked for, only deliver status for that span. */
+-		if (0 < span_query && dspan->pri.span != span_query) {
+-			continue;
+-		}
+-
+-		if (dspan->pri.pri) {
+-			count += sig_pri_ami_show_spans(s, show_cmd, &dspan->pri, dspan->dchannels,
+-				action_id);
+-		}
+-	}
+-
+-	astman_append(s,
+-		"Event: %sComplete\r\n"
+-		"Items: %d\r\n"
+-		"%s"
+-		"\r\n",
+-		show_cmd,
+-		count,
+-		action_id);
+-	return 0;
+-}
+-#endif	/* defined(HAVE_PRI) */
+-
+ #if defined(HAVE_SS7)
+ static int linkset_addsigchan(int sigchan)
+ {
+@@ -16942,10 +16755,9 @@
+ 	switch (cmd) {
+ 		case CLI_INIT:
+ 			e->command = "wat send sms";
+-			e->usage =
+-					"Usage: wat send sms <span> <number> <sms>\n"
+-					"       Send a sms on <span> <number> <sms>\n";
+-			return NULL;
++			e->usage = "Usage: wat send sms <span> <number> <sms>\n"
++					   "       Send a sms on <span> <number> <sms>\n";
++		return NULL;
+ 		case CLI_GENERATE:
+ 			return NULL;
+ 	}
+@@ -16975,9 +16787,8 @@
+ 	switch (cmd) {
+ 		case CLI_INIT:
+ 			e->command = "wat show spans";
+-			e->usage =
+-					"Usage: wat show spans\n"
+-					"       Displays WAT span information\n";
++			e->usage = "Usage: wat show spans\n"
++						"       Displays WAT span information\n";
+ 			return NULL;
+ 		case CLI_GENERATE:
+ 			return NULL;
+@@ -17001,9 +16812,8 @@
+ 	switch (cmd) {
+ 		case CLI_INIT:
+ 			e->command = "wat show span";
+-			e->usage =
+-					"Usage: wat show span <span>\n"
+-					"       Displays GSM Information on a given WAT span\n";
++			e->usage = "Usage: wat show span <span>\n"
++						"       Displays GSM Information on a given WAT span\n";
+ 			return NULL;
+ 		case CLI_GENERATE:
+ 			return complete_span_4(a->line, a->word, a->pos, a->n);
+@@ -17011,11 +16821,13 @@
+ 
+ 	if (a->argc < 4)
+ 		return CLI_SHOWUSAGE;
++
+ 	span = atoi(a->argv[3]);
+ 	if ((span < 1) || (span > NUM_SPANS)) {
+ 		ast_cli(a->fd, "Invalid span '%s'.  Should be a number from %d to %d\n", a->argv[3], 1, NUM_SPANS);
+ 		return CLI_SUCCESS;
+ 	}
++
+ 	if (!wats[span-1].wat.wat_span_id) {
+ 		ast_cli(a->fd, "No WAT running on span %d\n", span);
+ 		return CLI_SUCCESS;
+@@ -17035,9 +16847,8 @@
+ 	switch (cmd) {
+ 		case CLI_INIT:
+ 			e->command = "wat show version";
+-			e->usage =
+-					"Usage: wat show version\n"
+-					"	Show the libwat version\n";
++			e->usage = "Usage: wat show version\n"
++						"       Show the libwat version\n";
+ 			return NULL;
+ 		case CLI_GENERATE:
+ 			return NULL;
+@@ -17056,9 +16867,8 @@
+ 	switch (cmd) {
+ 		case CLI_INIT:
+ 			e->command = "wat exec";
+-			e->usage =
+-					"Usage: wat exec <span> <AT command>\n"
+-					"       Executes an arbitrary AT command in the given WAT span\n";
++			e->usage = "Usage: wat exec <span> <AT command>\n"
++						"       Executes an arbitrary AT command in the given WAT span\n";
+ 			return NULL;
+ 		case CLI_GENERATE:
+ 			return complete_span_4(a->line, a->word, a->pos, a->n);
+@@ -17066,11 +16876,13 @@
+ 
+ 	if (a->argc < 4)
+ 		return CLI_SHOWUSAGE;
++
+ 	span = atoi(a->argv[2]);
+ 	if ((span < 1) || (span > NUM_SPANS)) {
+ 		ast_cli(a->fd, "Invalid span '%s'.  Should be a number from %d to %d\n", a->argv[2], 1, NUM_SPANS);
+ 		return CLI_SUCCESS;
+ 	}
++
+ 	if (!wats[span-1].wat.wat_span_id) {
+ 		ast_cli(a->fd, "No WAT running on span %d\n", span);
+ 		return CLI_SUCCESS;
+@@ -17083,14 +16895,13 @@
+ 
+ #if defined(HAVE_WAT)
+ static struct ast_cli_entry dahdi_wat_cli[] = {
+-	/* AST_CLI_DEFINE(handle_wat_debug, "Enables WAT debugging on a span"), */
+ 	AST_CLI_DEFINE(handle_wat_send_sms, "Sends a SMS"),
+ 	AST_CLI_DEFINE(handle_wat_show_spans, "Displays WAT span information"),
+ 	AST_CLI_DEFINE(handle_wat_show_span, "Displays WAT span information"),
+ 	AST_CLI_DEFINE(handle_wat_exec_at, "Executes an arbitrary AT command"),
+ 	AST_CLI_DEFINE(handle_wat_version, "Displays libwat version"),
+ };
+-#endif	/* defined(HAVE_WAT) */
++#endif /* defined(HAVE_WAT) */
+ 
+ #if defined(HAVE_PRI)
+ #if defined(HAVE_PRI_CCSS)
+@@ -17217,10 +17028,11 @@
+ #ifdef HAVE_WAT
+ 	for (i = 0; i < NUM_SPANS; i++) {
+ 		if (wats[i].wat.master != AST_PTHREADT_NULL)
+-			pthread_cancel(wats[i].wat.master);
++		pthread_cancel(wats[i].wat.master);
+ 	}
+ 	ast_cli_unregister_multiple(dahdi_wat_cli, ARRAY_LEN(dahdi_wat_cli));
+ #endif
++
+ #if defined(HAVE_SS7)
+ 	for (i = 0; i < NUM_SPANS; i++) {
+ 		if (linksets[i].ss7.master != AST_PTHREADT_NULL)
+@@ -17242,9 +17054,6 @@
+ 	ast_manager_unregister("DAHDIDNDon");
+ 	ast_manager_unregister("DAHDIShowChannels");
+ 	ast_manager_unregister("DAHDIRestart");
+-#if defined(HAVE_PRI)
+-	ast_manager_unregister("PRIShowSpans");
+-#endif	/* defined(HAVE_PRI) */
+ 	ast_data_unregister(NULL);
+ 	ast_channel_unregister(&dahdi_tech);
+ 
+@@ -17282,6 +17091,7 @@
+ #endif	/* defined(HAVE_PRI_CCSS) */
+ 	sig_pri_unload();
+ #endif
++
+ #ifdef HAVE_WAT
+ 	for (i = 0; i < NUM_SPANS; i++) {
+ 		if (wats[i].wat.master && (wats[i].wat.master != AST_PTHREADT_NULL)) {
+@@ -17293,6 +17103,7 @@
+ 		}
+ 	}
+ #endif
++
+ #if defined(HAVE_SS7)
+ 	for (i = 0; i < NUM_SPANS; i++) {
+ 		if (linksets[i].ss7.master && (linksets[i].ss7.master != AST_PTHREADT_NULL))
+@@ -17303,8 +17114,6 @@
+ 	}
+ #endif	/* defined(HAVE_SS7) */
+ 	ast_cond_destroy(&ss_thread_complete);
+-
+-	dahdi_tech.capabilities = ast_format_cap_destroy(dahdi_tech.capabilities);
+ 	return 0;
+ }
+ 
+@@ -17471,127 +17280,11 @@
+ 	}
+ }
+ 
+-#if defined(HAVE_PRI)
+-#if defined(HAVE_PRI_DISPLAY_TEXT)
+-/*!
+- * \internal
+- * \brief Determine the configured display text options.
+- * \since 10.0
+- *
+- * \param value Configuration value string.
+- *
+- * \return Configured display text option flags.
+- */
+-static unsigned long dahdi_display_text_option(const char *value)
+-{
+-	char *val_str;
+-	char *opt_str;
+-	unsigned long options;
+-
+-	options = 0;
+-	val_str = ast_strdupa(value);
+-
+-	for (;;) {
+-		opt_str = strsep(&val_str, ",");
+-		if (!opt_str) {
+-			break;
+-		}
+-		opt_str = ast_strip(opt_str);
+-		if (!*opt_str) {
+-			continue;
+-		}
+-
+-		if (!strcasecmp(opt_str, "block")) {
+-			options |= PRI_DISPLAY_OPTION_BLOCK;
+-		} else if (!strcasecmp(opt_str, "name_initial")) {
+-			options |= PRI_DISPLAY_OPTION_NAME_INITIAL;
+-		} else if (!strcasecmp(opt_str, "name_update")) {
+-			options |= PRI_DISPLAY_OPTION_NAME_UPDATE;
+-		} else if (!strcasecmp(opt_str, "name")) {
+-			options |= (PRI_DISPLAY_OPTION_NAME_INITIAL | PRI_DISPLAY_OPTION_NAME_UPDATE);
+-		} else if (!strcasecmp(opt_str, "text")) {
+-			options |= PRI_DISPLAY_OPTION_TEXT;
+-		}
+-	}
+-	return options;
+-}
+-#endif	/* defined(HAVE_PRI_DISPLAY_TEXT) */
+-#endif	/* defined(HAVE_PRI) */
+-
+-#if defined(HAVE_PRI)
+-#if defined(HAVE_PRI_DATETIME_SEND)
+-/*!
+- * \internal
+- * \brief Determine the configured date/time send policy option.
+- * \since 10.0
+- *
+- * \param value Configuration value string.
+- *
+- * \return Configured date/time send policy option.
+- */
+-static int dahdi_datetime_send_option(const char *value)
+-{
+-	int option;
+-
+-	option = PRI_DATE_TIME_SEND_DEFAULT;
+-
+-	if (ast_false(value)) {
+-		option = PRI_DATE_TIME_SEND_NO;
+-	} else if (!strcasecmp(value, "date")) {
+-		option = PRI_DATE_TIME_SEND_DATE;
+-	} else if (!strcasecmp(value, "date_hh")) {
+-		option = PRI_DATE_TIME_SEND_DATE_HH;
+-	} else if (!strcasecmp(value, "date_hhmm")) {
+-		option = PRI_DATE_TIME_SEND_DATE_HHMM;
+-	} else if (!strcasecmp(value, "date_hhmmss")) {
+-		option = PRI_DATE_TIME_SEND_DATE_HHMMSS;
+-	}
+-
+-	return option;
+-}
+-#endif	/* defined(HAVE_PRI_DATETIME_SEND) */
+-#endif	/* defined(HAVE_PRI) */
+-
+ /*! process_dahdi() - ignore keyword 'channel' and similar */
+ #define PROC_DAHDI_OPT_NOCHAN  (1 << 0)
+ /*! process_dahdi() - No warnings on non-existing cofiguration keywords */
+ #define PROC_DAHDI_OPT_NOWARN  (1 << 1)
+ 
+-static void parse_busy_pattern(struct ast_variable *v, struct ast_dsp_busy_pattern *busy_cadence)
+-{
+-	int count_pattern = 0;
+-	int norval = 0;
+-	char *temp = NULL;
+-
+-	for (; ;) {
+-		/* Scans the string for the next value in the pattern. If none, it checks to see if any have been entered so far. */
+-		if(!sscanf(v->value, "%30d", &norval) && count_pattern == 0) { 
+-			ast_log(LOG_ERROR, "busypattern= expects either busypattern=tonelength,quietlength or busypattern=t1length, q1length, t2length, q2length at line %d.\n", v->lineno);
+-			break;
+-		}
+-
+-		busy_cadence->pattern[count_pattern] = norval; 
+-		
+-		count_pattern++;
+-		if (count_pattern == 4) {
+-			break;
+-		}
+-
+-		temp = strchr(v->value, ',');
+-		if (temp == NULL) {
+-			break;
+-		}
+-		v->value = temp + 1;
+-	}
+-	busy_cadence->length = count_pattern;
+-
+-	if (count_pattern % 2 != 0) { 
+-		/* The pattern length must be divisible by two */
+-		ast_log(LOG_ERROR, "busypattern= expects either busypattern=tonelength,quietlength or busypattern=t1length, q1length, t2length, q2length at line %d.\n", v->lineno);
+-	}
+-	
+-}
+-
+ static int process_dahdi(struct dahdi_chan_conf *confp, const char *cat, struct ast_variable *v, int reload, int options)
+ {
+ 	struct dahdi_pvt *tmp;
+@@ -17605,19 +17298,19 @@
+ 
+ 		/* Create the interface list */
+ 		if (!strcasecmp(v->name, "channel") || !strcasecmp(v->name, "channels")) {
+-			if (options & PROC_DAHDI_OPT_NOCHAN) {
++ 			if (options & PROC_DAHDI_OPT_NOCHAN) {
+ 				ast_log(LOG_WARNING, "Channel '%s' ignored.\n", v->value);
+-				continue;
++ 				continue;
+ 			}
+ 			if (build_channels(confp, v->value, reload, v->lineno, &found_pseudo)) {
+ 				if (confp->ignore_failed_channels) {
+ 					ast_log(LOG_WARNING, "Channel '%s' failure ignored: ignore_failed_channels.\n", v->value);
+ 					continue;
+ 				} else {
+-					return -1;
++ 					return -1;
+ 				}
+ 			}
+-			ast_debug(1, "Channel '%s' configured.\n", v->value);
++			ast_log(LOG_DEBUG, "Channel '%s' configured.\n", v->value);
+ 		} else if (!strcasecmp(v->name, "ignore_failed_channels")) {
+ 			confp->ignore_failed_channels = ast_true(v->value);
+ 		} else if (!strcasecmp(v->name, "buffers")) {
+@@ -17692,8 +17385,6 @@
+ 				confp->chan.dtmfrelax = 0;
+ 		} else if (!strcasecmp(v->name, "mailbox")) {
+ 			ast_copy_string(confp->chan.mailbox, v->value, sizeof(confp->chan.mailbox));
+-		} else if (!strcasecmp(v->name, "description")) {
+-			ast_copy_string(confp->chan.description, v->value, sizeof(confp->chan.description));
+ 		} else if (!strcasecmp(v->name, "hasvoicemail")) {
+ 			if (ast_true(v->value) && ast_strlen_zero(confp->chan.mailbox)) {
+ 				ast_copy_string(confp->chan.mailbox, cat, sizeof(confp->chan.mailbox));
+@@ -17715,7 +17406,9 @@
+ 		} else if (!strcasecmp(v->name, "busycount")) {
+ 			confp->chan.busycount = atoi(v->value);
+ 		} else if (!strcasecmp(v->name, "busypattern")) {
+-			parse_busy_pattern(v, &confp->chan.busy_cadence);
++			if (sscanf(v->value, "%30d,%30d", &confp->chan.busy_tonelength, &confp->chan.busy_quietlength) != 2) {
++				ast_log(LOG_ERROR, "busypattern= expects busypattern=tonelength,quietlength at line %d.\n", v->lineno);
++			}
+ 		} else if (!strcasecmp(v->name, "callprogress")) {
+ 			confp->chan.callprogress &= ~CALLPROGRESS_PROGRESS;
+ 			if (ast_true(v->value))
+@@ -18033,9 +17726,7 @@
+ #ifdef HAVE_WAT
+ 				} else if (!strcasecmp(v->value, "gsm")) {
+ 					confp->chan.sig = SIG_GSM;
+-#else
+-#ERROR(WAT NOT DEFINED)
+-#endif	/* defined (HAVE_WAT) */
++#endif
+ 				} else if (!strcasecmp(v->value, "auto")) {
+ 					confp->is_sig_auto = 1;
+ 				} else {
+@@ -18044,6 +17735,26 @@
+ 					confp->is_sig_auto = orig_auto;
+ 					ast_log(LOG_ERROR, "Unknown signalling method '%s' at line %d.\n", v->value, v->lineno);
+ 				}
++#ifdef HAVE_WAT
++				} else if (!strcasecmp(v->name, "moduletype")) {
++					if (!strcasecmp(v->value, "telit")) {
++						confp->wat.wat.wat_cfg.moduletype = WAT_MODULE_TELIT;
++					} else {
++						ast_log(LOG_WARNING, "Unknown WAT moduletype '%s' at line %d.\n", v->value, v->lineno);
++					}
++				} else if (!strcasecmp(v->name, "timeout_cid_name")) {
++					if (atoi(v->value) >= 0) {
++						confp->wat.wat.wat_cfg.timeout_cid_num = atoi(v->value);
++					} else {
++						ast_log(LOG_WARNING, "Invalid value for '%s' at line %d.\n", v->value, v->lineno);
++					}
++				} else if (!strcasecmp(v->name, "signal_poll_interval")) {
++					if (atoi(v->value) >= 0) {
++						confp->wat.wat.wat_cfg.signal_poll_interval = atoi(v->value);
++					} else {
++						ast_log(LOG_WARNING, "Invalid value for '%s' at line %d.\n", v->value, v->lineno);
++					}
++#endif
+ 			 } else if (!strcasecmp(v->name, "outsignalling") || !strcasecmp(v->name, "outsignaling")) {
+ 				if (!strcasecmp(v->value, "em")) {
+ 					confp->chan.outsigmod = SIG_EM;
+@@ -18080,28 +17791,6 @@
+ 				} else {
+ 					ast_log(LOG_ERROR, "Unknown signalling method '%s' at line %d.\n", v->value, v->lineno);
+ 				}
+-#ifdef HAVE_WAT
+-			} else if (!strcasecmp(v->name, "wat_moduletype")) {
+-				if (!strcasecmp(v->value, "telit")) {
+-					confp->wat.wat.wat_cfg.moduletype = WAT_MODULE_TELIT;
+-				} else {
+-					ast_log(LOG_WARNING, "Unknown WAT moduletype '%s' at line %d.\n", v->value, v->lineno);
+-				 }
+-			} else if (!strcasecmp(v->name, "wat_timeout_cid_name")) {
+-					if (atoi(v->value) >= 0) {
+-						confp->wat.wat.wat_cfg.timeout_cid_num = atoi(v->value);
+-					} else {
+-						ast_log(LOG_WARNING, "Invalid value for '%s' at line %d.\n", v->value, v->lineno);
+-					}
+-			} else if (!strcasecmp(v->name, "wat_signal_poll_interval")) {
+-				if (atoi(v->value) >= 0) {
+-					confp->wat.wat.wat_cfg.signal_poll_interval = atoi(v->value);
+-				} else {
+-					ast_log(LOG_WARNING, "Invalid value for '%s' at line %d.\n", v->value, v->lineno);
+-				}
+-			} else if (!strcasecmp(v->name, "wat_codecs")) {
+-				confp->wat.wat.wat_cfg.codec_mask = wat_encode_codec(v->value);
+-#endif
+ #ifdef HAVE_PRI
+ 			} else if (!strcasecmp(v->name, "pridialplan")) {
+ 				if (!strcasecmp(v->value, "national")) {
+@@ -18132,8 +17821,6 @@
+ 					confp->pri.pri.localdialplan = PRI_INTERNATIONAL_ISDN + 1;
+ 				} else if (!strcasecmp(v->value, "local")) {
+ 					confp->pri.pri.localdialplan = PRI_LOCAL_ISDN + 1;
+-				} else if (!strcasecmp(v->value, "from_channel")) {
+-					confp->pri.pri.localdialplan = 0;
+ 				} else if (!strcasecmp(v->value, "dynamic")) {
+ 					confp->pri.pri.localdialplan = -1;
+ 				} else if (!strcasecmp(v->value, "redundant")) {
+@@ -18141,26 +17828,6 @@
+ 				} else {
+ 					ast_log(LOG_WARNING, "Unknown PRI localdialplan '%s' at line %d.\n", v->value, v->lineno);
+ 				}
+-			} else if (!strcasecmp(v->name, "pricpndialplan")) {
+-				if (!strcasecmp(v->value, "national")) {
+-					confp->pri.pri.cpndialplan = PRI_NATIONAL_ISDN + 1;
+-				} else if (!strcasecmp(v->value, "unknown")) {
+-					confp->pri.pri.cpndialplan = PRI_UNKNOWN + 1;
+-				} else if (!strcasecmp(v->value, "private")) {
+-					confp->pri.pri.cpndialplan = PRI_PRIVATE + 1;
+-				} else if (!strcasecmp(v->value, "international")) {
+-					confp->pri.pri.cpndialplan = PRI_INTERNATIONAL_ISDN + 1;
+-				} else if (!strcasecmp(v->value, "local")) {
+-					confp->pri.pri.cpndialplan = PRI_LOCAL_ISDN + 1;
+-				} else if (!strcasecmp(v->value, "from_channel")) {
+-					confp->pri.pri.cpndialplan = 0;
+-				} else if (!strcasecmp(v->value, "dynamic")) {
+-					confp->pri.pri.cpndialplan = -1;
+-				} else if (!strcasecmp(v->value, "redundant")) {
+-					confp->pri.pri.cpndialplan = -2;
+-				} else {
+-					ast_log(LOG_WARNING, "Unknown PRI cpndialplan '%s' at line %d.\n", v->value, v->lineno);
+-				}
+ 			} else if (!strcasecmp(v->name, "switchtype")) {
+ 				if (!strcasecmp(v->value, "national"))
+ 					confp->pri.pri.switchtype = PRI_SWITCH_NI2;
+@@ -18325,19 +17992,6 @@
+ 			} else if (!strcasecmp(v->name, "hold_disconnect_transfer")) {
+ 				confp->pri.pri.hold_disconnect_transfer = ast_true(v->value);
+ #endif	/* defined(HAVE_PRI_CALL_HOLD) */
+-			} else if (!strcasecmp(v->name, "moh_signaling")
+-				|| !strcasecmp(v->name, "moh_signalling")) {
+-				if (!strcasecmp(v->value, "moh")) {
+-					confp->pri.pri.moh_signaling = SIG_PRI_MOH_SIGNALING_MOH;
+-				} else if (!strcasecmp(v->value, "notify")) {
+-					confp->pri.pri.moh_signaling = SIG_PRI_MOH_SIGNALING_NOTIFY;
+-#if defined(HAVE_PRI_CALL_HOLD)
+-				} else if (!strcasecmp(v->value, "hold")) {
+-					confp->pri.pri.moh_signaling = SIG_PRI_MOH_SIGNALING_HOLD;
+-#endif	/* defined(HAVE_PRI_CALL_HOLD) */
+-				} else {
+-					confp->pri.pri.moh_signaling = SIG_PRI_MOH_SIGNALING_MOH;
+-				}
+ #if defined(HAVE_PRI_CCSS)
+ 			} else if (!strcasecmp(v->name, "cc_ptmp_recall_mode")) {
+ 				if (!strcasecmp(v->value, "global")) {
+@@ -18380,26 +18034,9 @@
+ 			} else if (!strcasecmp(v->name, "mwi_mailboxes")) {
+ 				ast_copy_string(confp->pri.pri.mwi_mailboxes, v->value,
+ 					sizeof(confp->pri.pri.mwi_mailboxes));
+-			} else if (!strcasecmp(v->name, "mwi_vm_numbers")) {
+-				ast_copy_string(confp->pri.pri.mwi_vm_numbers, v->value,
+-					sizeof(confp->pri.pri.mwi_vm_numbers));
+ #endif	/* defined(HAVE_PRI_MWI) */
+ 			} else if (!strcasecmp(v->name, "append_msn_to_cid_tag")) {
+ 				confp->pri.pri.append_msn_to_user_tag = ast_true(v->value);
+-#if defined(HAVE_PRI_DISPLAY_TEXT)
+-			} else if (!strcasecmp(v->name, "display_send")) {
+-				confp->pri.pri.display_flags_send = dahdi_display_text_option(v->value);
+-			} else if (!strcasecmp(v->name, "display_receive")) {
+-				confp->pri.pri.display_flags_receive = dahdi_display_text_option(v->value);
+-#endif	/* defined(HAVE_PRI_DISPLAY_TEXT) */
+-#if defined(HAVE_PRI_MCID)
+-			} else if (!strcasecmp(v->name, "mcid_send")) {
+-				confp->pri.pri.mcid_send = ast_true(v->value);
+-#endif	/* defined(HAVE_PRI_MCID) */
+-#if defined(HAVE_PRI_DATETIME_SEND)
+-			} else if (!strcasecmp(v->name, "datetime_send")) {
+-				confp->pri.pri.datetime_send = dahdi_datetime_send_option(v->value);
+-#endif	/* defined(HAVE_PRI_DATETIME_SEND) */
+ #if defined(HAVE_PRI_L2_PERSISTENCE)
+ 			} else if (!strcasecmp(v->name, "layer2_persistence")) {
+ 				if (!strcasecmp(v->value, "keep_up")) {
+@@ -18518,20 +18155,6 @@
+ 				if (confp->mfcr2.metering_pulse_timeout > 500) {
+ 					ast_log(LOG_WARNING, "Metering pulse timeout greater than 500ms is not recommended, you have been warned!\n");
+ 				}
+-#if defined(OR2_LIB_INTERFACE) && OR2_LIB_INTERFACE > 2
+-			} else if (!strcasecmp(v->name, "mfcr2_dtmf_detection")) {
+-				confp->mfcr2.dtmf_detection = ast_true(v->value) ? 1 : 0;
+-			} else if (!strcasecmp(v->name, "mfcr2_dtmf_dialing")) {
+-				confp->mfcr2.dtmf_dialing = ast_true(v->value) ? 1 : 0;
+-			} else if (!strcasecmp(v->name, "mfcr2_dtmf_time_on")) {
+-				confp->mfcr2.dtmf_time_on = atoi(v->value);
+-			} else if (!strcasecmp(v->name, "mfcr2_dtmf_time_off")) {
+-				confp->mfcr2.dtmf_time_off = atoi(v->value);
+-#endif
+-#if defined(OR2_LIB_INTERFACE) && OR2_LIB_INTERFACE > 3
+-			} else if (!strcasecmp(v->name, "mfcr2_dtmf_end_timeout")) {
+-				confp->mfcr2.dtmf_end_timeout = atoi(v->value);
+-#endif
+ 			} else if (!strcasecmp(v->name, "mfcr2_get_ani_first")) {
+ 				confp->mfcr2.get_ani_first = ast_true(v->value) ? 1 : 0;
+ 			} else if (!strcasecmp(v->name, "mfcr2_double_answer")) {
+@@ -19093,14 +18716,15 @@
+ 			if (wats[x].wat.pvt) {
+ 				prepare_wat(wats + x);
+ 				if (sig_wat_start_wat(&wats[x].wat)) {
+-					ast_log(LOG_ERROR, "Unable to start sig-channel on span %d\n", x + 1);
+-					return -1;
++						ast_log(LOG_ERROR, "Unable to start sig-channel on span %d\n", x + 1);
++						return -1;
+ 				} else
+-					ast_verb(2, "Starting signalling monitor on span %d\n", x + 1);
++						ast_verb(2, "Starting signalling monitor on span %d\n", x + 1);
+ 			}
+ 		}
+ 	}
+ #endif
++
+ 	/* And start the monitor for the first time */
+ 	restart_monitor();
+ 	return 0;
+@@ -19294,18 +18918,10 @@
+ static int load_module(void)
+ {
+ 	int res;
+-	struct ast_format tmpfmt;
+ #if defined(HAVE_PRI) || defined(HAVE_SS7)
+ 	int y;
+ #endif	/* defined(HAVE_PRI) || defined(HAVE_SS7) */
+ 
+-	if (!(dahdi_tech.capabilities = ast_format_cap_alloc())) {
+-		return AST_MODULE_LOAD_FAILURE;
+-	}
+-	ast_format_cap_add(dahdi_tech.capabilities, ast_format_set(&tmpfmt, AST_FORMAT_SLINEAR, 0));
+-	ast_format_cap_add(dahdi_tech.capabilities, ast_format_set(&tmpfmt, AST_FORMAT_ULAW, 0));
+-	ast_format_cap_add(dahdi_tech.capabilities, ast_format_set(&tmpfmt, AST_FORMAT_ALAW, 0));
+-
+ #ifdef HAVE_PRI
+ 	memset(pris, 0, sizeof(pris));
+ 	for (y = 0; y < NUM_SPANS; y++) {
+@@ -19372,7 +18988,7 @@
+ 	ast_cli_register_multiple(dahdi_mfcr2_cli, ARRAY_LEN(dahdi_mfcr2_cli));
+ 	ast_register_application_xml(dahdi_accept_r2_call_app, dahdi_accept_r2_call_exec);
+ #endif
+-
++	
+ 	ast_cli_register_multiple(dahdi_cli, ARRAY_LEN(dahdi_cli));
+ 	/* register all the data providers */
+ 	ast_data_register_multiple(dahdi_data_providers, ARRAY_LEN(dahdi_data_providers));
+@@ -19384,9 +19000,6 @@
+ 	ast_manager_register_xml("DAHDIDNDoff", 0, action_dahdidndoff);
+ 	ast_manager_register_xml("DAHDIShowChannels", 0, action_dahdishowchannels);
+ 	ast_manager_register_xml("DAHDIRestart", 0, action_dahdirestart);
+-#if defined(HAVE_PRI)
+-	ast_manager_register_xml("PRIShowSpans", 0, action_prishowspans);
+-#endif	/* defined(HAVE_PRI) */
+ 
+ 	ast_cond_init(&ss_thread_complete, NULL);
+ 
+@@ -19412,26 +19025,13 @@
+ 	float scont = 0.0;
+ 	int idx;
+ 
+-	if (!text[0]) {
+-		return(0); /* if nothing to send, don't */
+-	}
+ 	idx = dahdi_get_index(c, p, 0);
+ 	if (idx < 0) {
+ 		ast_log(LOG_WARNING, "Huh?  I don't exist?\n");
+ 		return -1;
+ 	}
+-	if ((!p->tdd) && (!p->mate)) {
+-#if defined(HAVE_PRI)
+-#if defined(HAVE_PRI_DISPLAY_TEXT)
+-		ast_mutex_lock(&p->lock);
+-		if (dahdi_sig_pri_lib_handles(p->sig)) {
+-			sig_pri_sendtext(p->sig_pvt, text);
+-		}
+-		ast_mutex_unlock(&p->lock);
+-#endif	/* defined(HAVE_PRI_DISPLAY_TEXT) */
+-#endif	/* defined(HAVE_PRI) */
+-		return(0);  /* if not in TDD mode, just return */
+-	}
++	if (!text[0]) return(0); /* if nothing to send, don't */
++	if ((!p->tdd) && (!p->mate)) return(0);  /* if not in TDD mode, just return */
+ 	if (p->mate)
+ 		buf = ast_malloc(((strlen(text) + 1) * ASCII_BYTES_PER_CHAR) + END_SILENCE_LEN + HEADER_LEN);
+ 	else
+@@ -19440,10 +19040,7 @@
+ 		return -1;
+ 	mybuf = buf;
+ 	if (p->mate) {
+-		struct ast_format tmp;
+-		/* PUT_CLI_MARKMS is a macro and requires a format ptr called codec to be present */
+-		struct ast_format *codec = &tmp;
+-		ast_format_set(codec, AST_LAW(p), 0);
++		int codec = AST_LAW(p);
+ 		for (x = 0; x < HEADER_MS; x++) {	/* 50 ms of Mark */
+ 			PUT_CLID_MARKMS;
+ 		}
diff -dur --exclude=configure --new-file asterisk-1.8.7.1/include/asterisk/autoconfig.h.in asterisk-1.8.7.1.patched/include/asterisk/autoconfig.h.in
--- asterisk-1.8.7.1/include/asterisk/autoconfig.h.in	2011-09-19 12:57:40.000000000 -0400
+++ asterisk-1.8.7.1.patched/include/asterisk/autoconfig.h.in	2011-12-05 17:32:01.000000000 -0500
@@ -956,6 +956,9 @@
 /* Define to 1 if you have the `vprintf' function. */
 #undef HAVE_VPRINTF
 
+/* Define to 1 if you have the GSM AT library. */
+#undef HAVE_WAT
+
 /* Define to 1 if you have the <winsock2.h> header file. */
 #undef HAVE_WINSOCK2_H
 
@@ -1056,9 +1059,6 @@
 /* Define to the version of this package. */
 #undef PACKAGE_VERSION
 
-/* Define to 1 if the C compiler supports function prototypes. */
-#undef PROTOTYPES
-
 /* Define to necessary symbol if this constant uses a non-standard name on
    your system. */
 #undef PTHREAD_CREATE_JOINABLE
@@ -1078,11 +1078,6 @@
 /* Define to the type of arg 5 for `select'. */
 #undef SELECT_TYPE_ARG5
 
-/* Define to 1 if the `setvbuf' function takes the buffering type as its
-   second argument and the buffer pointer as the third, as on System V before
-   release 3. */
-#undef SETVBUF_REVERSED
-
 /* The size of `char *', as computed by sizeof. */
 #undef SIZEOF_CHAR_P
 
@@ -1118,12 +1113,27 @@
 /* Define to a type of the same size as fd_set.fds_bits[[0]] */
 #undef TYPEOF_FD_SET_FDS_BITS
 
-/* Define to 1 if on AIX 3.
-   System headers sometimes define this.
-   We just want to avoid a redefinition error message.  */
+/* Enable extensions on AIX 3, Interix.  */
 #ifndef _ALL_SOURCE
 # undef _ALL_SOURCE
 #endif
+/* Enable GNU extensions on systems that have them.  */
+#ifndef _GNU_SOURCE
+# undef _GNU_SOURCE
+#endif
+/* Enable threading extensions on Solaris.  */
+#ifndef _POSIX_PTHREAD_SEMANTICS
+# undef _POSIX_PTHREAD_SEMANTICS
+#endif
+/* Enable extensions on HP NonStop.  */
+#ifndef _TANDEM_SOURCE
+# undef _TANDEM_SOURCE
+#endif
+/* Enable general extensions on Solaris.  */
+#ifndef __EXTENSIONS__
+# undef __EXTENSIONS__
+#endif
+
 
 /* Define to 1 if running on Darwin. */
 #undef _DARWIN_UNLIMITED_SELECT
@@ -1131,11 +1141,6 @@
 /* Number of bits in a file offset, on hosts where this is settable. */
 #undef _FILE_OFFSET_BITS
 
-/* Enable GNU extensions on systems that have them.  */
-#ifndef _GNU_SOURCE
-# undef _GNU_SOURCE
-#endif
-
 /* Define to 1 to make fseeko visible on some hosts (e.g. glibc 2.2). */
 #undef _LARGEFILE_SOURCE
 
@@ -1152,20 +1157,6 @@
 /* Define to 1 if you need to in order for `stat' and other things to work. */
 #undef _POSIX_SOURCE
 
-/* Enable extensions on Solaris.  */
-#ifndef __EXTENSIONS__
-# undef __EXTENSIONS__
-#endif
-#ifndef _POSIX_PTHREAD_SEMANTICS
-# undef _POSIX_PTHREAD_SEMANTICS
-#endif
-#ifndef _TANDEM_SOURCE
-# undef _TANDEM_SOURCE
-#endif
-
-/* Define like PROTOTYPES; this can be used by system headers. */
-#undef __PROTOTYPES
-
 /* Define to empty if `const' does not conform to ANSI C. */
 #undef const
 
diff -dur --exclude=configure --new-file asterisk-1.8.7.1/makeopts.in asterisk-1.8.7.1.patched/makeopts.in
--- asterisk-1.8.7.1/makeopts.in	2011-08-25 11:27:06.000000000 -0400
+++ asterisk-1.8.7.1.patched/makeopts.in	2011-12-05 17:32:01.000000000 -0500
@@ -205,6 +205,9 @@
 PRI_INCLUDE=@PRI_INCLUDE@
 PRI_LIB=@PRI_LIB@
 
+WAT_INCLUDE=@WAT_INCLUDE@
+WAT_LIB=@WAT_LIB@
+
 RESAMPLE_INCLUDE=@RESAMPLE_INCLUDE@
 RESAMPLE_LIB=@RESAMPLE_LIB@
 
diff -dur --exclude=configure --new-file asterisk-1.8.7.1/menuselect/test/menuselect-tree asterisk-1.8.7.1.patched/menuselect/test/menuselect-tree
--- asterisk-1.8.7.1/menuselect/test/menuselect-tree	2009-07-20 17:00:37.000000000 -0400
+++ asterisk-1.8.7.1.patched/menuselect/test/menuselect-tree	2011-12-05 17:32:01.000000000 -0500
@@ -219,6 +219,7 @@
 	<depend>tonezone</depend>
 	<use>pri</use>
 	<use>ss7</use>
+	<use>wat</use>
 </member>
 <member name="chan_features" displayname="Feature Proxy Channel" remove_on_change="channels/chan_features.o channels/chan_features.so">
         <defaultenabled>no</defaultenabled>
